<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SMT Scripts: Mikino - Verification For Dummies: SMT and Induction by OCamlPro</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="../preface/index.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item expanded "><a href="../smt/index.html"><strong aria-hidden="true">3.</strong> SMT Solvers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smt/mikino.html" class="active"><strong aria-hidden="true">3.1.</strong> SMT Scripts: Mikino</a></li></ol></li><li class="chapter-item "><a href="../trans/index.html"><strong aria-hidden="true">4.</strong> Transition Systems</a></li><li class="chapter-item "><a href="../trans_smt/index.html"><strong aria-hidden="true">5.</strong> SMT and Transition Systems</a></li><li class="chapter-item "><a href="../bmc/index.html"><strong aria-hidden="true">6.</strong> Unrolling and BMC</a></li><li class="chapter-item "><a href="../mikino_bmc/index.html"><strong aria-hidden="true">7.</strong> BMC: Mikino</a></li><li class="chapter-item "><a href="../induction/index.html"><strong aria-hidden="true">8.</strong> Induction</a></li><li class="chapter-item "><a href="../mikino_induction/index.html"><strong aria-hidden="true">9.</strong> Induction: Mikino and Step Cex-s</a></li><li class="chapter-item "><a href="../strength/index.html"><strong aria-hidden="true">10.</strong> Candidate Strengthening</a></li><li class="chapter-item "><a href="../conclusion/index.html"><strong aria-hidden="true">11.</strong> Conclusion</a></li><li class="chapter-item "><a href="../mikino_install/index.html"><strong aria-hidden="true">12.</strong> Appendix: Mikino</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Verification For Dummies: SMT and Induction by OCamlPro</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="smt-scripts-mikino"><a class="header" href="#smt-scripts-mikino">SMT Scripts: Mikino</a></h1>
<p>This section as well as most following ones rely on <a href="https://github.com/OCamlPro/mikino_bin" title="Mikino binary repository">mikino</a>, a nice tool I wrote for
interacting with SMT solvers and perform induction-based analyses (which we will do soon). If you
want to follow along just make sure <a href="../mikino_install">you have mikino set up</a>. Be careful that
mikino requires Z3 to actually run, as discussed in the <a href="../mikino_install">setup instructions</a>.</p>
<p></p>
<p>Mikino has its own scripting language for interacting with SMT solvers. It is basically a
Rust-flavored version of <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> called <em>hsmt</em> (Human SMT). While readable, SMT-LIB 2
is designed to be written and parsed by programs, not humans. You probably noticed this yourself
reading the previous section.</p>
<p>We want to emphasize that mikino is <strong>not</strong> an SMT solver: when running hsmt scripts, mikino acts
as a thin layer between the hsmt code and Z3. Mikino translates your commands, passes them to Z3,
and handles/prettifies the result of the command if any. Whenever we say <em>mikino does something</em> in
this section, it's really Z3 doing through mikino.</p>
<p></p>
<p>We're going to go through what hsmt is shortly, but before we do know that you can run <code>mikino demo --script demo.rs</code> to generate a demo script file <code>demo.rs</code> which discusses more details about hsmt
that we can cover here. For instance, the demo discusses conditional branching (if-then-else) over
check-sat results (which SMT-LIB 2 does not have) which will not be mentioned here.</p>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>Consider the following formula.</p>
<pre><code class="language-text">vars {
   x y : int
}

   ┌───∧─────┐
   │         │
 x &gt; 7    ┌──∨──────┐
          │         │
          │         │
        y = 2*x   x = 11
</code></pre>
<p>Of course, the ASCII art tree representing the formula is <em>not</em> legal hsmt. An hsmt script declares
variables and uses them to <em>assert</em> formulas, <em>i.e.</em> specify to the solver what the constraints on
these variables are.</p>
<p>As you already guessed the first lines in the snippet above declare integer variables <code>x</code> and <code>y</code>.
<code>vars</code> block let you declare variables of type <code>int</code>, <code>bool</code> or <code>rat</code>(ional) as a comma-separated
(with optional trailing comma) list:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
   x y : int,
   flag1 : bool,
   flag2 : bool,
   z1 z2 z3 : rat,
}
<span class="boring">}
</span></code></pre></pre>
<p>Anyway, an hsmt assertion of our running example would look like this:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	(x &gt; 7) ∧ (
		y = 2*x ∨ x = 11
	)
}

check_sat!()
<span class="boring">}
</span></code></pre></pre>
<p>All hsmt commands (<code>vars</code>, <code>assert</code>, <code>check_sat</code>, ...) accept their input either in a block <code>{ ... }</code> or between parens <code>( ... )</code>.</p>
<p>The <code>assert</code> command feeds a constraint to the solver as a constraint. Next, we can ask the solver
to check the satisfiability of all the constraints (of which there is just one here) with
<code>check-sat</code>.</p>
<h2 id="playing-with-mikino-sat"><a class="header" href="#playing-with-mikino-sat">Playing with mikino: <code>sat</code></a></h2>
<p>Let's now run mikino on this tiny example. Create a file <code>test.rs</code> and copy the content of the
SMT-LIB script above. No special option is needed and you should get the following output.</p>
<pre><code class="language-text">&gt; mikino script test.rs
sat
success
</code></pre>
<p>Mikino answered <code>sat</code>, indicating that the formula is <em>&quot;satisfiable&quot;</em>: there exists a model (a
valuation of the variables) that make our constraints (just one in this case) <code>true</code>. This is nice,
but it would be better if mikino could give us a model to make sure it is not lying to us (it's
not). We can do so by adding a <code>get_model!()</code> command after the <code>check_sat!()</code>. (Note that
<code>get_model!()</code> is <strong>only</strong> legal after a <code>check_sat!()</code> yielded <code>sat</code>.)</p>
<pre><code class="language-rs">vars {
	x y : int
}

assert {
	(x &gt; 7) ∧ (
		y = 2*x ∨ x = 11
	)
}

check_sat!()
get_model!()
</code></pre>
<p>After updating <code>test.rs</code>, running mikino again will produce a model. You might not get exactly the
same model as the one reported here depending on the precise version of mikino/Z3 you are using and
possibly other factors (such as your operating system).</p>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 8,
    y: 16,
}
success
</code></pre>
<p>This valuation is a model because <code>(&gt; x 7) ≡ (&gt; 8 7)</code> holds (&quot;is true&quot;) and so does <code>(= y (* 2 x)) ≡ (= 16 (* 2 8))</code>: all constraints are verified.</p>
<blockquote>
<p>By the way, you might see a pattern here with the use of <code>!</code> after some commands' name. It is not
mandatory, but all commands that either <em>i)</em> can produce an output like <code>check_sat</code>, <code>get_model</code>,
<code>echo</code>, <code>println</code>, or <em>ii)</em> exit/crash the script (<code>exit</code>, <code>panic</code>) can be written with a <code>!</code> at
the end like <code>assert!()</code>, <code>println!(&quot;my message&quot;)</code>... to make them stand out visually.</p>
</blockquote>
<p><br />
</p>
<p>Now, we can assert more than one constraint. Mikino works on the conjunction of all constraints
---or at least Z3, behind the scene, does. In our running example, our only constraint is a
conjunction, meaning we could write it as two constraints.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert(x &gt; 7)
assert(y = 2*x ∨ x = 11)

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 8,
    y: 16,
}
success
</code></pre>
<p>Alternatively, <code>assert</code> actually takes as input a comma-separated list (with optional trailing
comma) of expressions, understood as a conjunction. So this also works:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	x &gt; 7,
	y = 2*x ∨ x = 11,
}

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 8,
    y: 16,
}
success
</code></pre>
<p><br />
</p>
<p>Let's now add the constraint that <code>y</code> is an odd number: <code>y % 2 = 1</code>. This should void the previous
model, and more generally any model that relies on making <code>y = 2*x</code> true to satisfy the constraints
since <code>y</code> would need to be both even and odd.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	x &gt; 7,
	y = 2*x ∨ x = 11,
	y % 2 = 1,
}

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<p>We now get</p>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 11,
    y: 1,
}
success
</code></pre>
<p>As expected, the solver now has to make the second constraint <code>true</code> through <code>x = 11</code>.</p>
<h2 id="playing-with-mikino-unsat"><a class="header" href="#playing-with-mikino-unsat">Playing with mikino: <code>unsat</code></a></h2>
<p>Let's add another constraint to make our problem <code>unsat</code>isfiable. In the latest version of our
example, the solver has no choice but to have <code>x</code> be <code>11</code> since it is the only way to verify the
second constraint (because the third constraint prevents <code>y</code> from being even).</p>
<p>We can simply constrain <code>x</code> to be even (which prevents <code>x</code> from being <code>11</code>), which we will write as
&quot;<code>x</code> cannot be odd&quot;.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	x &gt; 7,
	y = 2*x ∨ x = 11,
	y % 2 = 1,
}

assert {
	¬(x % 2 = 1),
}

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<p>Z3 knows exactly what we are doing and replies that the formula is unsatisfiable.</p>
<pre><code class="language-text">❯ z3 test.rs
unsat
|===| Error
| parse error at 18:1
|    | check_sat!()
| 18 | get_model!()&lt;EOI&gt;
|    | ^~~~ here
| - while requesting a model
| - smt-level error:
|   - solver error: &quot;line 18 column 10: model is not available&quot;
| - performing script step for file `./src/smt/code/ex_5.hsmt`
| - running `./src/smt/code/ex_5.hsmt` script
|===|
</code></pre>
<p>We get an error though, because it does not make sense to ask for a model if the formula is
unsatisfiable. <em>&quot;Unsatisfiable&quot;</em>, or <em>unsat</em>, means <em>&quot;has no model&quot;</em>, <em>i.e.</em> no valuation of the
variables can make all constraints true.</p>
<p><br />
</p>
<p>Now, what does this unsatisfiability result tell us? One way to see it is to consider the first
three constraints as some form of context. That is, the first three constraints correspond to some
point in a program where there are two unknown values <code>x</code> and <code>y</code>, and the first three constraints
encode what we know to be true about these values.</p>
<p>The last constraint can be seen as a question. Say that at that point in the program, there is an
assertion that <code>x</code> must be odd. We want to verify that it can never fail. From this point of view,
then the latest version of our running example amounts to asking &quot;given the context (first three
constraints), is it possible for <code>x</code> to <strong>not</strong> be odd?&quot;. In other words, we are asking the solver
to find some values that both verify our context and <strong>falsify</strong> the program's assertion.</p>
<p>The solver answers <em>&quot;no&quot;</em>: in this context, it is not possible for <code>x</code> not to be odd. This means
that we proved for us that the program's assertion can never fail (and can be compiled away). More
precisely, we proved that <strong>our encoding of the program's assertion</strong> can never fail. Whatever we
then do with this information depends on how much trust we have in the encoding.</p>
<p><br />
</p>
<p>What if, with different constraints, the negation of the program's assert statement was
satisfiable? Then, <a href="#playing-with-z3-sat">as we saw in the previous section</a>, solvers can give us a
<em>model</em>: a valuation of all the (relevant) variables involved in the check. this constitutes a
<em>counterexample</em>, which shows how it is possible to verify the whole context but still falsify the
program assertion, <em>i.e</em> satisfy <code>assert { ¬ &lt;program_assertion&gt; }</code>.</p>
<h2 id="outro"><a class="header" href="#outro">Outro</a></h2>
<p>SMT solvers are extremely powerful, flexible and expressive tools. <em>Powerful</em> because they are
highly optimized tools constantly improved by ongoing theoretical and practical research.
<em>Flexible</em> because many different theories are available, allowing to manipulate integers, strings,
arrays, algebraic data types, <em>etc.</em> And <em>expressive</em> because a great deal of verification problems
are amenable to SMT without too much trouble.</p>
<p>One such verification problem is <em>declarative transition system (induction-based) verification</em>, as
we will see in the following chapters.</p>
<!-- [z3 online]: https://rise4fun.com/z3 (Z3's online interface) -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../smt/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../trans/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../smt/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../trans/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
