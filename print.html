<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Verification For Dummies: SMT and Induction by OCamlPro</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="preface/index.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item "><a href="smt/index.html"><strong aria-hidden="true">3.</strong> SMT Solvers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smt/mikino.html"><strong aria-hidden="true">3.1.</strong> SMT Scripts: Mikino</a></li></ol></li><li class="chapter-item "><a href="trans/index.html"><strong aria-hidden="true">4.</strong> Transition Systems</a></li><li class="chapter-item "><a href="trans_smt/index.html"><strong aria-hidden="true">5.</strong> SMT and Transition Systems</a></li><li class="chapter-item "><a href="bmc/index.html"><strong aria-hidden="true">6.</strong> Unrolling and BMC</a></li><li class="chapter-item "><a href="mikino_bmc/index.html"><strong aria-hidden="true">7.</strong> BMC: Mikino</a></li><li class="chapter-item "><a href="induction/index.html"><strong aria-hidden="true">8.</strong> Induction</a></li><li class="chapter-item "><a href="mikino_induction/index.html"><strong aria-hidden="true">9.</strong> Induction: Mikino and Step Cex-s</a></li><li class="chapter-item "><a href="strength/index.html"><strong aria-hidden="true">10.</strong> Candidate Strengthening</a></li><li class="chapter-item "><a href="conclusion/index.html"><strong aria-hidden="true">11.</strong> Conclusion</a></li><li class="chapter-item "><a href="mikino_install/index.html"><strong aria-hidden="true">12.</strong> Appendix: Mikino</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Verification For Dummies: SMT and Induction by OCamlPro</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="verification-for-dummies-smt-and-induction"><a class="header" href="#verification-for-dummies-smt-and-induction">Verification for Dummies: SMT and Induction</a></h1>
<p>By <a href="https://www.ocamlpro.com" title="OCamlPro's official website">OCamlPro</a>.</p>
<ul>
<li>
<p>Adrien Champion</p>
<p><a href="mailto:adrien.champion@ocamlpro.com">adrien.champion@ocamlpro.com</a></p>
</li>
<li><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
      <img
          alt="Creative Commons License"
          style="border-width:0"
          src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"
      />
  </a>
<p>This work is licensed under a <a
      rel="license"
      href="http://creativecommons.org/licenses/by-sa/4.0/"
  >Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
</li>
</ul>
<p><br />
</p>
<p>This book broadly discusses <em>induction</em> as a <em>formal verification</em> technique, which here really
means <em>formal program verification</em>. I will use concrete, runnable examples whenever possible.
Some of them can run directly in a browser, while others require to run small easy-to-retrieve
tools locally. Such is the case for pretty much all examples dealing directly with induction.</p>
<p>The next chapters discuss the following notions:</p>
<ul>
<li>formal logics and formal frameworks;</li>
<li>SMT-solving: modern, <em>low-level</em> verification building blocks;</li>
<li>declarative transition systems;</li>
<li>transition system unrolling;</li>
<li>BMC and induction proofs over transition systems;</li>
<li>candidate strengthening.</li>
</ul>
<p><br />
</p>
<p>The approach presented here is far from being the only one when it comes to program verification.
It happens to be relatively simple to understand, and I believe that familiarity with the notions
discussed here makes understanding other approaches significantly easier.</p>
<p>This book thus hopes to serve both as a relatively deep dive into the specific technique of
SMT-based induction, as well as an example of the technical challenges inherent to both developing
and using automated proof engines.</p>
<p><br />
</p>
<p>Some chapters contain a few pieces of Rust code. Usually to provide a runnable version of a system
under discussion, or to serve as example of actual code that we want to encode and verify. Some
notions of Rust could definitely help in places, but this is not mandatory (probably).</p>
<p><br />
</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="./preface">Preface</a></p>
<p>High-level presentation of (formal) verification as a formal method.</p>
</li>
<li>
<p><a href="./smt">SMT Solvers</a></p>
<p>SMT solvers are the basic building blocks for many modern verification tools.</p>
</li>
<li>
<p><a href="./trans">Transition Systems</a></p>
<p>Transition systems are <em>one way</em> to encode a wide variety of programs in a framework suited for
formal verification. Following sections will discuss all notions in the context of transition
systems as they are fairly easy to understand. They definitely have downsides, but one can get a
surprising mileage out of them if careful.</p>
</li>
<li>
<p><a href="./trans_smt">SMT and Transition Systems</a></p>
<p>Transition systems are represented by formulas that SMT solver can work on. This chapter lays
out the foundation for more complex SMT-based analyses.</p>
</li>
<li>
<p><a href="./bmc">Unrolling and BMC</a></p>
<p><strong>B</strong>ounded <strong>M</strong>odel-<strong>C</strong>hecking is, <em>in general</em>, not a verification technique. Still, it is
quite useful for finding <em>concrete counterexample</em>, <em>i.e.</em> a concrete behavior of the system
that illustrates a problem. It is also a good context to showcase what one can do with a
transition system using an SMT solver.</p>
</li>
<li>
<p><a href="./mikino_bmc">BMC: Mikino</a></p>
<p><a href="https://github.com/OCamlPro/mikino_bin" title="Mikino on github">Mikino</a> is a small proof engine that can perform BMC. While it requires getting
familiar with its simple input format, it abstracts SMT solvers for us so that we can focus on
higher-level concepts.</p>
</li>
<li>
<p><a href="./induction">Induction</a></p>
<p>Induction is a natural step from BMC: it requires a simple BMC-like <em>base</em> check but also a
<em>step</em> check which is simple to encode with SMT solvers. Since induction <em>is</em> a verification
technique contrary to BMC, this is where we finally start proving things.</p>
</li>
<li>
<p><a href="./mikino_induction">Induction: Mikino and Step Cex-s</a></p>
<p>In addition to BMC, <a href="https://github.com/OCamlPro/mikino_bin" title="Mikino on github">mikino</a> can also perform induction. It can thus prove <em>inductive</em>
properties of a system. Once again, mikino abstracts the SMT solver for us. Mikino is designed
with user experience in mind, so by the end of this chapter you will probably be able to
experiment by modifying systems introduced so far, or write your own.</p>
</li>
<li>
<p><a href="./strength">Candidate Strengthening</a></p>
<p>This chapter is quite technical and a bit theoretical. Make sure you are comfortable with all
the notions discussed so far before diving in.</p>
<p>An invariant for a system is not necessarily inductive. This last part of the series focuses on
candidate strengthening, which is really about <em>discovering</em> useful, powerful facts about the
system's behavior. Such facts can make non-inductive invariants inductive, which is why most
modern induction-based verification engines focus heavily on candidate strengthening.</p>
<p>This chapter, unlike previous ones, aims at proving an actual piece of code by encoding it as a
transition system. It also touches on the complexity of verification and the notion of
undecidability.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<blockquote>
<p>This preface is a high-level introduction to formal verification. It then goes into the details
of what a formal verification tool looks like, and which aspects of such tools we will discuss in
later posts.</p>
</blockquote>
<p><br />
</p>
<p><a href="https://en.wikipedia.org/wiki/Mathematical_logic">Formal logics</a> deal with reasoning in the context of a formal framework. For example, a
<em>type system</em> is a formal framework. <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">Strongly-typed</a> programming languages rely on
type systems to (dis)prove that programs are well-typed. For example, consider the following Rust
function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn demo(n: usize) -&gt; usize {
    let mut res = n;
    if n % 2 == 0 {
        res = 2*n;
    } else {
        res = 2*n + 1;
    }
    return res;
}
println!(&quot;demo(7): {}&quot;, demo(7))
<span class="boring">}
</span></code></pre></pre>
<p>When the Rust compiler type-checks this function, it goes through its body and aggregates some
<em>constraints</em>. These constraints are an abstraction of the definition that the type system can
reason about to (dis)prove that the program respects some type-related properties. For instance,
<code>let mut res = n;</code> is abstracted as <em>&quot;<code>res</code> has the same type as <code>n</code>&quot;</em>. The fact that, at this
point, <code>res</code> is equal to <code>n</code> is not relevant for type-checking.</p>
<p><br />
</p>
<p>Rust's most peculiar feature is the notion of <em>ownership</em> and the associated
<a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html"><em>borrow-checker</em></a>. Similar to type-checking, borrow-checking abstracts the actual
code to encode it in a framework so that it can reason about the program. Type-checking's core
notion is that of types, and the equivalent for borrow-checking is <em>lifetimes</em>, <em>i.e.</em> the length
of time for which some data exists and can be used.</p>
<blockquote>
<p>Understanding lifetimes and the borrow-checker is not required for the next chapters. It is
presented here as an example of encoding a problem in a framework where constraints can be
constructed. Looking at these constraints, a tool (the borrow-checker here) can draw conclusion
regarding the (un)safety of the program.</p>
</blockquote>
<p>Consider the following Rust function, where <code>'a</code> is a lifetime parameter.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DOES NOT COMPILE
fn demo&lt;'a&gt;(n: &amp;'a mut usize) -&gt; &amp;'a mut usize {
    let mut res = *n;
    res += 1;
    // error[E0515]: cannot return reference to local variable `res`
    return &amp;mut res;
    //     ^^^^^^^^ returns a reference to data owned by the current function
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, this code does not compile because of the notion of <em>ownership</em>. Here, the function's body
<em>owns</em> <code>res</code> since it created (allocated) it and, since it does not transfer <code>res</code> itself to the
caller (only <code>&amp;mut res</code>), <code>res</code> is freed when we exit the body of the function (<code>res</code>'s owner):</p>
<ul>
<li><em>i)</em> <code>res</code> only lives for the lifetime <code>'demo</code> (lifetime of the body of <code>demo</code>)</li>
<li><em>ii)</em> <code>demo</code> returns a mutable reference to <code>res</code></li>
<li><em>iii)</em> the output of <code>demo</code> is a mutable reference of the same lifetime <code>'a</code> as its input</li>
</ul>
<p>The compiler can then infer that <code>demo</code>'s output has lifetime <code>'demo</code> from <em>i)</em> and <em>ii)</em>, and thus
<code>'a</code> must be equal to <code>'demo</code> from <em>iii)</em>. However, it follows from <em>iii)</em> that <code>'a</code> must, in
general, live strictly longer (be valid for longer) than <code>'demo</code>. So, we have <code>'a &gt; 'demo</code> and
since <code>'a = 'demo</code>, we reach a contradiction: <code>'demo &gt; 'demo</code>. This means that there is no solution
to the constraints, and the compiler proceeds to reject the program by telling us that <code>res</code> does
not live long enough.</p>
<p><br />
</p>
<p>Type-checking and borrow-checking are examples of verification processes. In both cases, the
semantics of the program is encoded in a proof system. The encoding of the program and the rules of
the proof system let the compiler build a set of <em>constraints</em>.</p>
<p>It is interesting to note that <em>formal verification</em>, at its core, really consists in <strong>searching
for a proof</strong> of correctness. As we saw, the borrow-checker aggregates constraints and then looks
for a solution. In the paragraph above, we were looking for an interpretation of the different
lifetimes of the program that verifies, or <em>&quot;satisfies&quot;</em> all the constraint.</p>
<p><br />
</p>
<p>Searching for a proof, which consists in trying to <em>solve</em> some constraints is done by a <em>solver</em>.
From our point of view, the solver is our main building block. It is the block responsible for producing an actual answer from the encoding of the verification problem.</p>
<p>Now, the real question is <em>&quot;what does it mean for the constraints to have a solution, or to have
none?&quot;</em>. In the case of type-checking, the type constraints have a solution <em>if and only if</em> the
program is well-typed. It says very little about memory-safety and thread-safety on its own, which
is why type-checking is followed by borrow-checking in the Rust compiler.</p>
<p>The borrow-checker on the other hand builds constraints such that the existence of a solution
implies the absence of <strong>U</strong>ndefined <strong>B</strong>ehavior (UB) in the program. At least as long as there
are no <code>unsafe</code> blocks in it.</p>
<h2 id="properties-and-specification"><a class="header" href="#properties-and-specification">Properties and Specification</a></h2>
<p>The main point of the discussion above is to highlight a well-known fact in formal verification.
There is no such thing as <em>verifying a program</em>: all we can do is verify that <em>some properties</em>
hold for a program. This might seem like a trivial distinction, but it has consequences that
verification novices tend to overlook.</p>
<p>Type-checking and borrow-checking verify <em>built-in</em> properties: the program is well-typed and
cannot exhibit UB. We do not need to write a <em>specification</em> to tell them to verify these
properties. (Arguably, the type/ownership information we write throughout the program acts as a
partial/local specification.)</p>
<p><br />
</p>
<p>As a consequence, if we want to verify something the compiler is not able to do, we need two
things. First, we need some kind of <em>specification</em>, <em>i.e.</em> the properties we want to prove. We
might want to prove relatively general properties, for instance that no division by zero can occur.
Similar to type-checking and borrow-checking, this kind of property is built-in: whatever the
program to verify is, the property stays the same.</p>
<p>But our properties might depend on the exact program that goes through the verification process.
For example, we might want to prove input/output <em>contracts</em> on the functions of the programs we
analyze: the output of <code>fun_1</code> is positive, the output of <code>fun_2</code> is strictly greater than its
second input... In this case, programs will need some kind of annotation to <em>specify</em> these
contracts. Contrary to built-in properties, these program-specific properties are an input of the
verification tool.</p>
<h2 id="solvers-and-encoding"><a class="header" href="#solvers-and-encoding">Solvers and Encoding</a></h2>
<p>The second thing we need is a solver in which we can reason about the properties we are interested
in, on the programs we are interested in. In general, the solver will not accept the programs we
want to solve directly: we need to perform some encoding to generate the constraints for the solver.</p>
<p>The endgame is to build a verification tool that looks something like this:</p>
<pre><code class="language-text">
                              ┌───────────────────────┐
                              │   Verification Tool   │
                              ├───────────────────────┤
 ┌─────────────────────┐      │                       │
 │   Program to check  │      │     ┌──────────┐      │
 │and properties if not├──────┼─────► Encoding │      │
 │      built-in       │      │     └────┬─────┘      │
 └─────────────────────┘      │          │constraints │
                              │          │            │
                              │      ┌───▼─────┐      │
                              │      │ Solving │      │
                              │      └───┬─────┘      │
                              │          │success     │
                              │          │or failure  │
 ┌──────────────────────┐     │  ┌───────▼─────────┐  │
 │ User-friendly output ◄─────┼──┤ Post-processing │  │
 └──────────────────────┘     │  └─────────────────┘  │
                              │                       │
                              └───────────────────────┘

</code></pre>
<h3 id="expressiveness"><a class="header" href="#expressiveness">Expressiveness</a></h3>
<p>An important thing we have to consider is the <em>expressiveness</em> of the solver: it must be able to
represent and reason about our programs well enough that it is able to check our properties.</p>
<p><strong>Spoiler alert</strong>: verification is expensive. Usable, practical formal verification requires quite
a lot of clever engineering at every level. Also, generally speaking, the more expressive a solver
is the more expensive using it will be. Roughly speaking, ideally, a good/efficient solver for a
verification process is a solver that can handle exactly what we need and nothing else.</p>
<p>This is in fact how verification projects start, usually. Verification experts will take a very
long look at the kind of programs and properties targeted by the project and establish a list of
suitable solvers. Crucial aspects to look for in this process include</p>
<ul>
<li><strong>types</strong> of the values manipulated: booleans, integers, floats, hash sets, lists, user-defined
types...</li>
<li><strong>operations</strong> over these values: linear multiplication, non-linear multiplication, modulo...</li>
<li><strong>control flow</strong>: recursion, iterators, loops, pattern-matching, switch-case...</li>
</ul>
<p>Delimiting some kind of <em>expressiveness perimeter</em> to describe what we want the solver to support
is crucial and quite technical. The immediate danger is to get this perimeter wrong, and later
realize that aspects we missed make the solver we selected useless. This is why it tends to be
difficult to extend the expressiveness of a verification framework in directions not identified in
early stages.</p>
<p>If, when we chose the solver, all we had were booleans and integers with the usual operations over
them, it is for example very unlikely that we will be able to handle hash sets without huge changes
in the verification framework such as changing the solver.</p>
<h3 id="soundness-of-the-encoding"><a class="header" href="#soundness-of-the-encoding">Soundness (of the Encoding)</a></h3>
<p>Solvers have a notion of <em>soundness</em>. Roughly, a solver is <em>sound</em> if it can only prove <em>valid</em>
results (meaning it cannot prove things that are <em>&quot;wrong&quot;</em>). Since we are interested in <em>using</em>
(not <em>designing</em>) solvers, let's not go into more details on the notion of solver soundness and
only consider sound solvers.</p>
<p><br />
</p>
<p>There is a second notion of <em>soundness</em> however, which concerns the <em>encoding</em>. The <em>encoding</em> is
the process of going from an input program (and specification) to whatever kind of system the
solver can work on. This step will typically abstract the semantics of the program, as generally
speaking we cannot represent its exact semantics in the solver's input language.</p>
<p>The process of encoding is <em>sound</em> if whenever we prove that the encoded program verifies some
property <code>Prop</code>, then necessarily the original program verifies <code>Prop</code> as well. In case it is not
clear, if the goal is formal verification then <strong>we need the encoding to be sound</strong>. Otherwise, a
proof on the encoded program tells us nothing of the real program, <em>i.e.</em> the one we want to verify
in the first place.</p>
<blockquote>
<p>This is not to say that unsound encodings are necessarily useless. They can be useful if we are
interested solely in finding bugs for instance. Since we will not try to prove anything, it is
fine for the encoding to be unsound as long as it allows us to find actual/potential bugs.</p>
</blockquote>
<h2 id="outro"><a class="header" href="#outro">Outro</a></h2>
<p>I hope I got across the point that setting up a verification process in a (semi-)industrial context
requires a great deal of inspection. It requires assessing very precisely what kind of program we
want to analyze, and what kind of property we want to check. Widening the perimeter of
programs/properties supported can be arbitrarily complex.</p>
<p><br />
</p>
<p>Another important point is that the actual verification framework should be written very carefully.
While the solver is usually very trustworthy, any issue in the steps between the input program and
specification and the solving (parsing, pre-processing and encoding) potentially voids any
successful proof attempt. The solver <strong>must</strong> work on a correct encoding of the problem for the
result to mean anything.</p>
<p>Note that the problem is less severe for failed proof attempts that produce a <em>counterexample</em> (an
<em>executable</em> witness of a falsification of the property). Checking that the counterexample makes
sense for the original program is easy and fast. But a proof of correctness relies on the encoding
being sound and correctly implemented.</p>
<blockquote>
<p>There are ways to mitigate this kind of problem. Soundness can be formally proved. The frontend
can be made redundant by implementing it twice by two different teams in two different languages
(two or more), and checking they produce exactly the same constraints. Solver-side, <em>proof
logging</em> consists in having the solver log the logical steps of the actual proof it found so that
they can be checked by one or more separate tools.</p>
</blockquote>
<h2 id="next"><a class="header" href="#next">Next</a></h2>
<p>The following posts dive into SMT-based transition system induction, with some property
strengthening at the end. We will first get to know <em>SMT solvers</em>, which are powerful, flexible and
generally quite amazing tools. Next are <em>(declarative) transition systems</em>, which are the kind of
programs we will analyze. They are relatively simple to understand and require little encoding to
analyze them, meaning the encoding will be understandable when we look at it.</p>
<p>Next let's discuss <em>bounded model checking</em>, which on its own cannot (usually) prove anything: it
<em>just</em> finds counterexamples (bugs). The three posts after that discuss basic and more advanced
induction techniques.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smt-solvers"><a class="header" href="#smt-solvers">SMT Solvers</a></h1>
<blockquote>
<p>SMT solvers are basic building blocks for most modern verification tools. While studying SMT
solvers is particularly rewarding for developing such tools, understanding SMT forces to grasp
concepts that are very useful even for high-level users. Later chapters will rely heavily on SMT
solvers and readers are encouraged to run and modify examples themselves, or even create new ones.</p>
</blockquote>
<p><br />
</p>
<p>Let's go over a few theory-level notions before we actually start playing with SMT solvers. A
<strong>S</strong>atisfiability <strong>M</strong>odulo <strong>T</strong>heory (SMT) solver is a solver for establishing whether some
constraints expressed in <strong>M</strong>any-<strong>S</strong>orted <strong>F</strong>irst <strong>O</strong>rder <strong>L</strong>ogic (MSFOL) are
<em>satisfiable</em>. Let's unpack this.</p>
<p>First, MSFOL is built on FOL (<strong>F</strong>irst <strong>O</strong>rder <strong>L</strong>ogic), which basically means <em>&quot;boolean
formulas&quot;</em>. For instance, <code>a ∧ (false ∨ b ∨ c)</code> is a FOL formula, where <code>∧</code> is conjunction (<code>&amp;&amp;</code>)
and <code>∨</code> is disjunction (<code>||</code>). So this formula <em>evaluates</em> to <code>true</code> if and only if <code>a</code> is <code>true</code>
and either <code>b</code> or <code>c</code> is <code>true</code> (since <code>false</code> tends not to be <code>true</code>). We can represent this
formula as a tree, where leaves are boolean literals and nodes are boolean operators.</p>
<pre><code class="language-text"> ┌───∧───┐
 │       │
 a    ┌──∨──┬───────┐
      │     │       │
      │     │       │
    false   b       c
</code></pre>
<p>The leaves of the tree are <em>atoms</em>. MSFOL essentially extends FOL by allowing atoms to be formulas
in other theories such as integers, strings, arrays, <em>etc.</em> For instance, with <code>x</code> and <code>y</code> integers
and <code>arr</code> an array:</p>
<pre><code class="language-text">   ┌───∧─────┐
   │         │
 x &gt; 7    ┌──∨────┬───────┐
          │       │       │
          │       │       │
        false   y ≤ x   arr[y] = x + 1
</code></pre>
<p>Note that the last atom, <code>arr[y] = x + 1</code>, mixes array selection <code>arr[y]</code> with addition over
integers <code>x + 1</code>.</p>
<h2 id="z3"><a class="header" href="#z3">Z3</a></h2>
<p>Examples in the next sections (and the next chapter) will rely on the <a href="https://github.com/Z3Prover/z3" title="Z3 on github">Z3 SMT solver</a> to
actually run. You can build it from source or recover a binary from the <a href="https://github.com/Z3Prover/z3/releases" title="Z3's releases on github">release page</a>.
The version should not matter too much for what we'll do, but for reference this guide used
<code>v4.8.12</code>.</p>
<p>From this point forward I assume readers have a Z3 binary called <code>z3</code> in their path. That is,
running the command <code>z3 -version</code> should not fail and produce an output similar to</p>
<pre><code class="language-text">Z3 version 4.8.13 - 64 bit
</code></pre>
<p>While I recommend Z3, other efficient solvers exist and include <a href="https://alt-ergo.ocamlpro.com" title="Alt-Ergo homepage">Alt-Ergo</a>, <a href="https://cvc4.github.io/" title="CVC4 homepage">CVC4</a> and
<a href="https://yices.csl.sri.com" title="Yices 2 homepage">Yices 2</a>. Solvers tend to be good at distinct kinds of problem from each other, and
verification frameworks routinely run several of them in parallel, wait for the quickest answer,
and discard solver instances that are still running.</p>
<!-- Last, while we recommend having Z3 available locally, you can run the examples in this section
using only the [Z3 online playground][z3 online]. Beware that all following chapters about induction
require to have Z3 in your path. -->
<p><br />
</p>
<h2 id="satisfiability"><a class="header" href="#satisfiability">Satisfiability</a></h2>
<p>Formula satisfiability is concerned about whether it is possible to make some formula evaluate to
<code>true</code>. More precisely, is it possible to find a valuation for the variables appearing in the
formula under which the formula is <code>true</code>. Such a valuation is called a <em>model</em> of the formula. Let
us write a tiny example and start running Z3 to play with satisfiability directly.</p>
<blockquote>
<p>To be precise, <em>SAT</em> stands for the <em>boolean satisfiability problem</em>, which deals with finding
models for purely boolean formulas. <em>&quot;SMT&quot;</em> adds <em>&quot;Modulo Theory&quot;</em> to <em>&quot;Satisfiability&quot;</em> to
specify that atoms of the formula can mention theories different from booleans (integers, reals,
arrays, <em>etc.</em>) in its atoms, and that models must respect the rules of these theories.</p>
</blockquote>
<p><br />
</p>
<h2 id="smt-lib-2"><a class="header" href="#smt-lib-2">SMT-LIB 2</a></h2>
<p>For simplicity's sake, let's only allow atoms to mention integers. Consider the following formula.</p>
<pre><code class="language-text">(declare-const x Int)
(declare-const y Int)

   ┌───∧─────┐
   │         │
 x &gt; 7    ┌──∨──────┐
          │         │
          │         │
        y = 2*x   x = 11
</code></pre>
<p>The first two lines declare <em>&quot;constants&quot;</em> <code>x</code> and <code>y</code>. As programmers, we can see them as
<em>&quot;variables&quot;</em> in the sense that they represent an unknown value of type <code>Int</code>. This syntax comes
from the <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2 standard</a>, which is the standard <em>scripting</em> language for interacting
with SMT solvers. Most, if not all, SMT solvers support SMT-LIB 2 input.</p>
<p>Of course, the ASCII art tree representing the formula is <em>not</em> legal SMT-LIB 2. An SMT-LIB 2 script
declares constants (and more) and uses these constants to <em>assert</em> formulas, <em>i.e.</em> specify to the
solver what the constraints are.</p>
<p>Also, SMT-LIB formulas are written using <em>prefix notation</em> (or <em>Polish notation</em>). For instance, <code>y = 2*x</code> would be written <code>(= y (* 2 x))</code>. This is a compromise between ease of printing/parsing and
human readability. SMT-LIB is really meant to be used by programs to communicate, not for humans to
actually write by hand. Still, it is readable enough for pedagogic and debugging purposes.</p>
<blockquote>
<p><a href="https://code.visualstudio.com" title="VS Code homepage">VS Code</a> has an extension for SMT-LIB syntax highlighting (<code>.smt2</code> files). The pieces of SMT-LIB
code I will show in this book will not have syntax highlighting, unfortunately. I apologize
for this problem, and encourage readers to copy these pieces of code in an editor that supports
SMT-LIB using the button at the top-right of the code blocks.</p>
</blockquote>
<p>Anyway, an SMT-LIB assertion of our running example would look like this:</p>
<pre><code class="language-text">(declare-const x Int)
(declare-const y Int)

(assert (and
	(&gt; x 7)
	(or (= y (* 2 x)) (= x 11))
))

(check-sat)
</code></pre>
<p>The <code>assert</code> command feeds a constraint to the solver. Next, we can ask the solver to check
the satisfiability of all the constraints (of which there is just one here) with <code>check-sat</code>.</p>
<h2 id="playing-with-z3-sat"><a class="header" href="#playing-with-z3-sat">Playing with Z3: <code>sat</code></a></h2>
<p>Let's now run Z3 on this tiny example. Create a file <code>test.smt2</code> and copy the content of the
SMT-LIB script above. No special option is needed and you should get the following output.</p>
<pre><code class="language-text">❯ z3 test.smt2
sat
</code></pre>
<p>Z3 simply answered <code>sat</code>, indicating that the formula is <em>&quot;satisfiable&quot;</em>: there exists a model (a
valuation of the variables) that make our constraints <code>true</code>. This is nice, but it would be better
if Z3 could give us a model to make sure it is not lying to us (it's not). We can do so by adding a
<code>get-model</code> command after the <code>check-sat</code>. (Note that <code>get-model</code> is <strong>only</strong> legal after a
<code>check-sat</code> yielded <code>sat</code>.)</p>
<pre><code class="language-text">(declare-const x Int)
(declare-const y Int)

(assert (and
	(&gt; x 7)
	(or (= y (* 2 x)) (= x 11))
))

(check-sat)
(get-model)
</code></pre>
<p>After updating <code>test.smt2</code>, running Z3 again will produce a model. You might not get exactly the
same model as the one reported here depending on the precise version of Z3 you are using and
possibly other factors (such as your operating system).</p>
<pre><code class="language-text">❯ z3 test.smt2
sat
(
  (define-fun y () Int
    16)
  (define-fun x () Int
    8)
)
</code></pre>
<p>The model is slightly cryptic. Z3 defines <code>x</code> and <code>y</code> as functions taking no arguments, which means
that they are constants. This is because all functions are <em>pure</em> in SMT-LIB, meaning they always
produce the same output when given the same inputs. Hence, a function with no arguments can only
produce one value, and is therefore the same as a constant. In fact, <code>(define-fun &lt;ident&gt; () &lt;type&gt; &lt;val&gt;)</code> is the same as <code>(define-const &lt;ident&gt; &lt;type&gt; &lt;val&gt;)</code>, and the <code>(declare-const &lt;ident&gt; &lt;type&gt;)</code> we used in the SMT-LIB script is equivalent to <code>(declare-fun &lt;ident&gt; () &lt;type&gt;)</code>. Again,
in SMT-LIB (and pure functional languages) a constant is just a function that takes no argument.</p>
<p>This valuation is a model because <code>(&gt; x 7) ≡ (&gt; 8 7)</code> holds and so does <code>(= y (* 2 x)) ≡ (= 16 (* 2 8))</code>.</p>
<p><br />
</p>
<p>Now, remember that we can assert more than one constraint, and that Z3 works on the conjunction of
all constraints. In our running example, our only constraint is a conjunction, meaning we could
write it as two constraints.</p>
<pre><code class="language-text">(declare-const x Int)
(declare-const y Int)

(assert (&gt; x 7))
(assert (or (= y (* 2 x)) (= x 11)))

(check-sat)
(get-model)
</code></pre>
<p>Let's now add the constraint that <code>y</code> is an odd number: <code>(= (mod y 2) 1)</code>. This should void the
previous model, and more generally any model that relies on making <code>(= y (* 2 x))</code> true to satisfy
the constraints. (Since <code>y</code> would need to be both even and odd.)</p>
<pre><code class="language-text">(declare-const x Int)
(declare-const y Int)

(assert (&gt; x 7))
(assert (or (= y (* 2 x)) (= x 11)))
(assert (= (mod y 2) 1))

(check-sat)
(get-model)
</code></pre>
<p>We now get</p>
<pre><code class="language-text">❯ z3 test.smt2
sat
(
  (define-fun x () Int
    11)
  (define-fun y () Int
    1)
)
</code></pre>
<p>As expected, Z3 now has to make the second constraint <code>true</code> through <code>(= x 11)</code>.</p>
<h2 id="playing-with-z3-unsat"><a class="header" href="#playing-with-z3-unsat">Playing with Z3: <code>unsat</code></a></h2>
<p>Let's add another constraint to make these constraints unsatisfiable. In the latest version of our
example, Z3 has no choice but to have <code>x</code> be <code>11</code> since it is the only way to verify the second
constraint (because the third constraint prevents <code>y</code> from being even).</p>
<p>We can simply constrain <code>x</code> to be even (which prevents <code>x</code> to be <code>11</code>), which we will write as &quot;<code>x</code>
cannot be odd&quot;.</p>
<pre><code class="language-text">(declare-const x Int)
(declare-const y Int)

(assert (&gt; x 7))
(assert (or (= y (* 2 x)) (= x 11)))
(assert (= (mod y 2) 1))

(assert (not (= (mod x 2) 1)))

(check-sat)
(get-model)
</code></pre>
<p>Z3 knows exactly what we are doing and replies that the formula is unsatisfiable.</p>
<pre><code class="language-text">❯ z3 test.smt2
unsat
(error &quot;line 11 column 10: model is not available&quot;)
</code></pre>
<p>We get an error though, because it does not make sense to ask for a model if the formula is
unsatisfiable. <em>&quot;Unsatisfiable&quot;</em>, or <em>unsat</em>, means <em>&quot;has no model&quot;</em> (<em>i.e.</em> no valuation of the
variables can make all constraints true).</p>
<p><br />
</p>
<p>Now, what does this unsatisfiability result tell us? One way to see it is to consider the first
three constraints as some form of context. That is, the first three constraints correspond to some
point in a program where there are two unknown values <code>x</code> and <code>y</code>, and the first three constraints
encode what we know to be true about these values.</p>
<p>The last constraint can be seen as a question. Say that at that point in the program, there is an
assertion that <code>x</code> must be odd. We want to verify that this assert can never fail. From this point
of view, then the latest version of our running example amounts to asking &quot;given the context (first
three constraints), is it possible for <code>x</code> to <strong>not</strong> be odd?&quot;. In other words, we are asking Z3 to
find some values that both verify our context and <strong>falsify</strong> the program's assertion.</p>
<p>Z3 answers &quot;no&quot;: in this context, it is not possible for <code>x</code> not to be odd. This means that Z3
proved for us that the program's assert statement can never fail (and can be compiled away).</p>
<p>What if, with different constraints, the negation of the program's assert statement was
satisfiable? Then, <a href="smt/index.html#playing-with-z3-sat">as we saw in the previous section</a>, Z3 can give us a
<em>model</em>: a valuation of all the (relevant) variables involved in the check. this constitutes a
<em>counterexample</em>, which shows how it is possible to verify the whole context but still falsify the
program assertion (<em>i.e</em> satisfy the SMT-LIB-level <code>(assert (not &lt;program_assertion&gt;))</code>).</p>
<h2 id="outro-1"><a class="header" href="#outro-1">Outro</a></h2>
<p>SMT solvers are extremely powerful, flexible and expressive tools. <em>Powerful</em> because they are
highly optimized tools constantly improved by ongoing theoretical and practical research.
<em>Flexible</em> because many different theories are available, allowing to manipulate integers, strings,
arrays, algebraic data types, <em>etc.</em> And <em>expressive</em> because a great deal of verification problems
are amenable to SMT without too much trouble.</p>
<p>One such verification problem is <em>declarative transition system (induction-based) verification</em>, as
we will see in the following chapters.</p>
<p><br />
</p>
<p>The next section is optional, it is a repetition of the present section using <a href="https://github.com/OCamlPro/mikino_bin" title="Mikino binary repository">mikino</a>'s version of SMT-LIB 2: <em>hsmt</em>. Hsmt is a Rust-flavored syntax for (a subset of) the SMT-LIB
2 scripting language. As we will see, mikino's primary functionality is performing SMT-based
induction checks; hsmt is just a by-product feature that I thought could be useful for teaching
what SMT is and how to interact with SMT solvers. Note that while mikino only supports a subset of
SMT-LIB 2 (function definitions are not supported for example), it also adds new features such as
conditional branching (if-then-else) over check-sat results.</p>
<p>If that's not interesting for you right now, feel free to move on directly to <a href="smt/../trans">the next
chapter</a>.</p>
<!-- [z3 online]: https://rise4fun.com/z3 (Z3's online interface) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="smt-scripts-mikino"><a class="header" href="#smt-scripts-mikino">SMT Scripts: Mikino</a></h1>
<p>This section as well as most following ones rely on <a href="https://github.com/OCamlPro/mikino_bin" title="Mikino binary repository">mikino</a>, a nice tool I wrote for
interacting with SMT solvers and perform induction-based analyses (which we will do soon). If you
want to follow along just make sure <a href="smt/../mikino_install">you have mikino set up</a>. Be careful that
mikino requires Z3 to actually run, as discussed in the <a href="smt/../mikino_install">setup instructions</a>.</p>
<p></p>
<p>Mikino has its own scripting language for interacting with SMT solvers. It is basically a
Rust-flavored version of <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> called <em>hsmt</em> (Human SMT). While readable, SMT-LIB 2
is designed to be written and parsed by programs, not humans. You probably noticed this yourself
reading the previous section.</p>
<p>We want to emphasize that mikino is <strong>not</strong> an SMT solver: when running hsmt scripts, mikino acts
as a thin layer between the hsmt code and Z3. Mikino translates your commands, passes them to Z3,
and handles/prettifies the result of the command if any. Whenever we say <em>mikino does something</em> in
this section, it's really Z3 doing through mikino.</p>
<p></p>
<p>We're going to go through what hsmt is shortly, but before we do know that you can run <code>mikino demo --script demo.rs</code> to generate a demo script file <code>demo.rs</code> which discusses more details about hsmt
that we can cover here. For instance, the demo discusses conditional branching (if-then-else) over
check-sat results (which SMT-LIB 2 does not have) which will not be mentioned here.</p>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>Consider the following formula.</p>
<pre><code class="language-text">vars {
   x y : int
}

   ┌───∧─────┐
   │         │
 x &gt; 7    ┌──∨──────┐
          │         │
          │         │
        y = 2*x   x = 11
</code></pre>
<p>Of course, the ASCII art tree representing the formula is <em>not</em> legal hsmt. An hsmt script declares
variables and uses them to <em>assert</em> formulas, <em>i.e.</em> specify to the solver what the constraints on
these variables are.</p>
<p>As you already guessed the first lines in the snippet above declare integer variables <code>x</code> and <code>y</code>.
<code>vars</code> block let you declare variables of type <code>int</code>, <code>bool</code> or <code>rat</code>(ional) as a comma-separated
(with optional trailing comma) list:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
   x y : int,
   flag1 : bool,
   flag2 : bool,
   z1 z2 z3 : rat,
}
<span class="boring">}
</span></code></pre></pre>
<p>Anyway, an hsmt assertion of our running example would look like this:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	(x &gt; 7) ∧ (
		y = 2*x ∨ x = 11
	)
}

check_sat!()
<span class="boring">}
</span></code></pre></pre>
<p>All hsmt commands (<code>vars</code>, <code>assert</code>, <code>check_sat</code>, ...) accept their input either in a block <code>{ ... }</code> or between parens <code>( ... )</code>.</p>
<p>The <code>assert</code> command feeds a constraint to the solver as a constraint. Next, we can ask the solver
to check the satisfiability of all the constraints (of which there is just one here) with
<code>check-sat</code>.</p>
<h2 id="playing-with-mikino-sat"><a class="header" href="#playing-with-mikino-sat">Playing with mikino: <code>sat</code></a></h2>
<p>Let's now run mikino on this tiny example. Create a file <code>test.rs</code> and copy the content of the
SMT-LIB script above. No special option is needed and you should get the following output.</p>
<pre><code class="language-text">&gt; mikino script test.rs
sat
success
</code></pre>
<p>Mikino answered <code>sat</code>, indicating that the formula is <em>&quot;satisfiable&quot;</em>: there exists a model (a
valuation of the variables) that make our constraints (just one in this case) <code>true</code>. This is nice,
but it would be better if mikino could give us a model to make sure it is not lying to us (it's
not). We can do so by adding a <code>get_model!()</code> command after the <code>check_sat!()</code>. (Note that
<code>get_model!()</code> is <strong>only</strong> legal after a <code>check_sat!()</code> yielded <code>sat</code>.)</p>
<pre><code class="language-rs">vars {
	x y : int
}

assert {
	(x &gt; 7) ∧ (
		y = 2*x ∨ x = 11
	)
}

check_sat!()
get_model!()
</code></pre>
<p>After updating <code>test.rs</code>, running mikino again will produce a model. You might not get exactly the
same model as the one reported here depending on the precise version of mikino/Z3 you are using and
possibly other factors (such as your operating system).</p>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 8,
    y: 16,
}
success
</code></pre>
<p>This valuation is a model because <code>(&gt; x 7) ≡ (&gt; 8 7)</code> holds (&quot;is true&quot;) and so does <code>(= y (* 2 x)) ≡ (= 16 (* 2 8))</code>: all constraints are verified.</p>
<blockquote>
<p>By the way, you might see a pattern here with the use of <code>!</code> after some commands' name. It is not
mandatory, but all commands that either <em>i)</em> can produce an output like <code>check_sat</code>, <code>get_model</code>,
<code>echo</code>, <code>println</code>, or <em>ii)</em> exit/crash the script (<code>exit</code>, <code>panic</code>) can be written with a <code>!</code> at
the end like <code>assert!()</code>, <code>println!(&quot;my message&quot;)</code>... to make them stand out visually.</p>
</blockquote>
<p><br />
</p>
<p>Now, we can assert more than one constraint. Mikino works on the conjunction of all constraints
---or at least Z3, behind the scene, does. In our running example, our only constraint is a
conjunction, meaning we could write it as two constraints.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert(x &gt; 7)
assert(y = 2*x ∨ x = 11)

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 8,
    y: 16,
}
success
</code></pre>
<p>Alternatively, <code>assert</code> actually takes as input a comma-separated list (with optional trailing
comma) of expressions, understood as a conjunction. So this also works:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	x &gt; 7,
	y = 2*x ∨ x = 11,
}

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 8,
    y: 16,
}
success
</code></pre>
<p><br />
</p>
<p>Let's now add the constraint that <code>y</code> is an odd number: <code>y % 2 = 1</code>. This should void the previous
model, and more generally any model that relies on making <code>y = 2*x</code> true to satisfy the constraints
since <code>y</code> would need to be both even and odd.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	x &gt; 7,
	y = 2*x ∨ x = 11,
	y % 2 = 1,
}

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<p>We now get</p>
<pre><code class="language-text">&gt; mikino script test.rs
sat
model {
    x: 11,
    y: 1,
}
success
</code></pre>
<p>As expected, the solver now has to make the second constraint <code>true</code> through <code>x = 11</code>.</p>
<h2 id="playing-with-mikino-unsat"><a class="header" href="#playing-with-mikino-unsat">Playing with mikino: <code>unsat</code></a></h2>
<p>Let's add another constraint to make our problem <code>unsat</code>isfiable. In the latest version of our
example, the solver has no choice but to have <code>x</code> be <code>11</code> since it is the only way to verify the
second constraint (because the third constraint prevents <code>y</code> from being even).</p>
<p>We can simply constrain <code>x</code> to be even (which prevents <code>x</code> from being <code>11</code>), which we will write as
&quot;<code>x</code> cannot be odd&quot;.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vars {
	x y : int
}

assert {
	x &gt; 7,
	y = 2*x ∨ x = 11,
	y % 2 = 1,
}

assert {
	¬(x % 2 = 1),
}

check_sat!()
get_model!()
<span class="boring">}
</span></code></pre></pre>
<p>Z3 knows exactly what we are doing and replies that the formula is unsatisfiable.</p>
<pre><code class="language-text">❯ z3 test.rs
unsat
|===| Error
| parse error at 18:1
|    | check_sat!()
| 18 | get_model!()&lt;EOI&gt;
|    | ^~~~ here
| - while requesting a model
| - smt-level error:
|   - solver error: &quot;line 18 column 10: model is not available&quot;
| - performing script step for file `./src/smt/code/ex_5.hsmt`
| - running `./src/smt/code/ex_5.hsmt` script
|===|
</code></pre>
<p>We get an error though, because it does not make sense to ask for a model if the formula is
unsatisfiable. <em>&quot;Unsatisfiable&quot;</em>, or <em>unsat</em>, means <em>&quot;has no model&quot;</em>, <em>i.e.</em> no valuation of the
variables can make all constraints true.</p>
<p><br />
</p>
<p>Now, what does this unsatisfiability result tell us? One way to see it is to consider the first
three constraints as some form of context. That is, the first three constraints correspond to some
point in a program where there are two unknown values <code>x</code> and <code>y</code>, and the first three constraints
encode what we know to be true about these values.</p>
<p>The last constraint can be seen as a question. Say that at that point in the program, there is an
assertion that <code>x</code> must be odd. We want to verify that it can never fail. From this point of view,
then the latest version of our running example amounts to asking &quot;given the context (first three
constraints), is it possible for <code>x</code> to <strong>not</strong> be odd?&quot;. In other words, we are asking the solver
to find some values that both verify our context and <strong>falsify</strong> the program's assertion.</p>
<p>The solver answers <em>&quot;no&quot;</em>: in this context, it is not possible for <code>x</code> not to be odd. This means
that we proved for us that the program's assertion can never fail (and can be compiled away). More
precisely, we proved that <strong>our encoding of the program's assertion</strong> can never fail. Whatever we
then do with this information depends on how much trust we have in the encoding.</p>
<p><br />
</p>
<p>What if, with different constraints, the negation of the program's assert statement was
satisfiable? Then, <a href="smt/mikino.html#playing-with-z3-sat">as we saw in the previous section</a>, solvers can give us a
<em>model</em>: a valuation of all the (relevant) variables involved in the check. this constitutes a
<em>counterexample</em>, which shows how it is possible to verify the whole context but still falsify the
program assertion, <em>i.e</em> satisfy <code>assert { ¬ &lt;program_assertion&gt; }</code>.</p>
<h2 id="outro-2"><a class="header" href="#outro-2">Outro</a></h2>
<p>SMT solvers are extremely powerful, flexible and expressive tools. <em>Powerful</em> because they are
highly optimized tools constantly improved by ongoing theoretical and practical research.
<em>Flexible</em> because many different theories are available, allowing to manipulate integers, strings,
arrays, algebraic data types, <em>etc.</em> And <em>expressive</em> because a great deal of verification problems
are amenable to SMT without too much trouble.</p>
<p>One such verification problem is <em>declarative transition system (induction-based) verification</em>, as
we will see in the following chapters.</p>
<!-- [z3 online]: https://rise4fun.com/z3 (Z3's online interface) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="transition-systems"><a class="header" href="#transition-systems">Transition Systems</a></h1>
<blockquote>
<p>This chapter is a bit abstract, there will be no fun manipulations 😿. The next chapter builds on
this one and is nothing but fun manipulations 😺 on the notions and examples introduced here.
Transition systems are the <em>&quot;objects&quot;</em> we will later analyze and are, in a sense, relatively
close to pieces of actual code (loops). This chapter starts bridging the gap between the
relatively high-level notion of transition system and SMT solvers which are relatively low-level
tools.</p>
</blockquote>
<p><br />
</p>
<p>A <em>(declarative) transition system</em> describes an infinite loop updating some <em>state</em>. The <em>state</em>
can be understood as some variables storing some data. These variables are usually called <em>state
variables</em> and they characterize the system completely. At each <em>step</em>, or <em>iteration of the loop</em>,
the state is updated (the state can change). A loop, even an infinite loop, has to start somewhere.
It may have more than one way to start itself: the <em>initial states</em> encapsulate all the different
ways the loop can start.</p>
<p><br />
</p>
<p>Say we have a simple stopwatch system. It features a <code>start_stop</code> button (toggles counting) and a
<code>reset</code> button. Say also this system counts time as an integer <code>cnt</code>. While <code>start_stop</code> and
<code>reset</code> are inputs (users control whether they are pressed or not), <code>cnt</code> corresponds to the
stopwatch's display: it is an output.</p>
<p>We also need an internal variable <code>is_counting</code> to remember whether we are counting or not:
<code>start_stop</code> toggles counting, meaning we need to remember if we were previously counting or not to
decide what a press of the <code>start_stop</code> button does. Hence, the state variables (<code>svars</code>) of our
stopwatch are</p>
<pre><pre class="playground"><code class="language-rust  no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	// inputs, `true` if pressed
	start_stop reset: bool,
	// internal variable
	is_counting: bool,
	// output
	cnt: int,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>As we will see later, this is the actual syntax we will use once we start playing with the mikino
induction-based checker.</p>
</blockquote>
<p>The description of this system is</p>
<ul>
<li>the system is initially not counting;</li>
<li>when not counting, a press on <code>start_stop</code> switch to counting mode (and conversely);</li>
<li>a press on <code>reset</code> resets the counter to <code>0</code>;</li>
<li>when counting and not resetting, <code>cnt</code> keeps incrementing.</li>
</ul>
<details>
	<summary>Expand this for a runnable implementation in Rust.</summary>
<pre><pre class="playground"><code class="language-rust  editable">type Int = i64;
struct State {
    start_stop: bool,
    reset: bool,
    is_counting: bool,
    cnt: Int, // arbitrary precision integer (ℕ)
}
impl State {
    fn init(start_stop: bool, reset: bool, random_cnt: Int) -&gt; State {
        State {
            start_stop,
            reset,
            // Initially not counting, unless `start_stop` is pressed
            // and triggers counting.
            is_counting: start_stop,
            cnt: if reset { 0 } else { random_cnt },
        }
    }
    fn step(&amp;mut self, start_stop: bool, reset: bool) {
        self.start_stop = start_stop;
        self.reset = reset;
        // Need to toggle `self.is_counting`?
        if self.start_stop {
            self.is_counting = !self.is_counting
        }
        // `cnt` update
        self.cnt = if self.reset {
            0
        } else if self.is_counting {
            self.cnt + 1
        } else {
            self.cnt
        };
    }
    fn to_string(&amp;self) -&gt; String {
        format!(
            &quot;cnt: {}, {}counting&quot;,
            self.cnt,
            if self.is_counting { &quot;&quot; } else { &quot;not &quot; }
        )
    }
}

fn main() {
    let mut state = State::init(false, false, -71);
    let mut step_count = 0;
    println!(&quot;initial state: {}&quot;, state.to_string());

    let mut step_show = |start_stop, reset, count_check| {
        if start_stop {
            println!(&quot;`start_stop` pressed&quot;)
        }
        if reset {
            println!(&quot;`reset` pressed&quot;)
        }
        state.step(start_stop, reset);
        step_count += 1;
        println!(&quot;@{} | {}&quot;, step_count, state.to_string());
        assert_eq!(state.cnt, count_check);
    };

    step_show(true, false, -70);
    step_show(false, false, -69);
    step_show(false, false, -68);
    step_show(false, false, -67);
    step_show(false, true, 0);
    step_show(false, false, 1);
    step_show(false, false, 2);
    step_show(false, false, 3);
    step_show(true, false, 3);
    step_show(false, false, 3);
    step_show(false, false, 3);
}
</code></pre></pre>
</details>
<p><br />
</p>
<h2 id="initial-predicate"><a class="header" href="#initial-predicate">Initial Predicate</a></h2>
<p>Let us think in terms of constraints: what must the values of the state variables verify to be a
legal initial state? We only have one constraint, <code>reset =&gt; cnt = 0</code>. That is, if <code>reset</code> is
<code>true</code>, then <code>cnt</code> must be <code>0</code>, otherwise anything goes. Given the description of the system, this
constraint captures the legal initial states and only the legal initial states.</p>
<p>This is called the <em>init predicate</em> of the transition system. The init predicate takes a state
valuation as input, and is true if and only if that state valuation is a legal initial state. We
can write it in pseudo-code as <code>init(s) ≜ s.reset ⇒ s.cnt = 0</code> or, equivalently, <code>init(s) ≜ ¬s.reset ∨ (s.cnt = 0)</code>: <em>&quot;either <code>reset</code> is <code>false</code> or <code>cnt</code> is <code>0</code>&quot;</em>.</p>
<blockquote>
<p>It might seem like a detail, but you should <strong>not</strong> think of <code>s.cnt = 0</code> as an assignment. It is
really a constraint that evaluates to <code>true</code> or <code>false</code> depending on the value of <code>s.cnt</code>. If it
helps, you can think of <code>=</code> as the usual <code>==</code> operator found in most programming languages.</p>
</blockquote>
<p>Our initial predicate is not complete though. The specification also tells us that we are
originally <em>not counting</em>, and that when <code>start_stop</code> is <code>true</code> we should toggle counting on/off.
That is, the initial value of <code>is_counting</code> should be <code>false</code> when <code>start_stop</code> is <code>false</code> (not
pressed), and <code>true</code> when <code>start_stop</code> is <code>true</code> (pressed). Hence, the initial value of
<code>is_counting</code> is <code>start_stop</code>. Our initial predicate is thus</p>
<pre><code class="language-text">init(s) ≜ (s.reset ⇒ s.cnt = 0) ∧ (s.is_counting = s.start_stop)
</code></pre>
<p><br />
</p>
<h2 id="transition-relation"><a class="header" href="#transition-relation">Transition Relation</a></h2>
<p>So at this point we have a notion of state (data) maintained by the transition system, and a
predicate (formula) that is true on a state valuation if and only if it is a legal initial state.
We are only missing the description of how the system evolves.</p>
<p>This is what the <em>transition relation</em> (a.k.a <em>step relation</em>) does. Its job is to examine the
relation between two state valuations <code>s</code> and <code>'s</code>, and evaluate to <code>true</code> if and only <code>'s</code> is a
legal successor of <code>s</code>. The first part of the <em>transition relation</em> deals with <code>is_counting</code>, which
should be toggled by <code>start_stop</code>. This is a constraint, if <code>'s</code> is a successor of <code>s</code> then they
should verify</p>
<ul>
<li><code>'s.start_stop ⇒ ('s.is_counting = ¬s.is_counting)</code>, and</li>
<li><code>¬'s.start_stop ⇒ ('s.is_counting = s.is_counting)</code>.</li>
</ul>
<p>Note that we still have a constraint when <code>start_stop</code> is not pressed: the value should not change.
If we did not constrain <code>'s.is_counting</code> in this case, then it would be unconstrained and thus
could take any value. These two constraints are arguable more readable as</p>
<ul>
<li><code>'s.is_counting = if 's.start_stop { ¬s.is_counting } else { s.is_counting }</code>.</li>
</ul>
<p><br />
</p>
<p>Next, the system's description discusses how <code>cnt</code> evolves, which gives the following constraints:</p>
<ul>
<li><code>'s.reset ⇒ ('s.cnt = 0)</code>,</li>
<li><code>'s.is_counting ⇒ ('s.cnt = s.cnt + 1)</code>, and</li>
<li><code>¬'s.is_counting ⇒ ('s.cnt = s.cnt)</code>.</li>
</ul>
<p>Most readers might notice that these constraints will not work well together. Whenever <code>reset</code> is
pressed <code>cnt</code> must be <code>0</code>, and at the same time it must be either incremented or unchanged
depending on the value of <code>is_counting</code>. In most cases, these constraints will have no solution.</p>
<details>
	<summary>Expand this for a concrete example of a conflict.</summary>
<blockquote>
<p>Say <code>s.cnt = 1</code>, and both <code>'s.reset</code> and <code>'s.is_counting</code> are <code>true</code>. Then by the first
constraint, we must have <code>'s.cnt = 0</code>; by the second constraint, we must also have <code>'s.cnt = 2</code>.
Hence, both constraints are in conflict and, together, they are unsatisfiable.</p>
</blockquote>
</details>
<p>Assuming the order of the points in the description of the system matters, we can solve this problem
by making the <code>reset</code> behavior preempt the behavior related to <code>is_counting</code>. We get</p>
<ul>
<li><code>'s.reset ⇒ ('s.cnt = 0)</code>,</li>
<li><code>('s.is_counting ∧ ¬'s.reset) ⇒ ('s.cnt = s.cnt + 1)</code>, and</li>
<li><code>(¬'s.is_counting ∧ ¬'s.reset) ⇒ ('s.cnt = s.cnt)</code>.</li>
</ul>
<p>Alternatively, we can rewrite these constraints as</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'s.cnt =
	if 's.reset { 0 }
	else if 's.is_counting { s.cnt + 1 }
	else { s.cnt }
<span class="boring">}
</span></code></pre></pre>
<p>Our transition relation is thus</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trans(s, 's) =
	  ( 's.start_stop ⇒ ('s.is_counting = ¬s.is_counting))
	∧ (¬'s.start_stop ⇒ ('s.is_counting =  s.is_counting))
	∧ (
		's.cnt =
			if 's.reset { 0 }
			else if 's.is_counting { s.cnt + 1 }
			else { s.cnt }
	)
<span class="boring">}
</span></code></pre></pre>
<p><br />
</p>
<p>Notice that <code>trans</code> only really constrains <code>'s.is_counting</code> and <code>'s.cnt</code>. This makes sense as the
two other states variables <code>'s.start_stop</code> and <code>'s.reset</code> (both of type <code>bool</code>) are seen as
<em>inputs</em>. Since they are not constrained, they can take any (boolean) value at all.</p>
<p>Notice also that, if we fix some values for <code>'s.start_stop</code> and <code>'s.reset</code>, then <code>trans</code> is
<em>deterministic</em>: <code>s</code>, whatever it is, can only have one successor.</p>
<table><thead><tr><th style="text-align: center"><code>'s.start_stop</code></th><th style="text-align: center"><code>'s.reset</code></th><th style="text-align: center"><code>'s.is_counting</code></th><th style="text-align: center"><code>'s.cnt</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>s.is_counting</code></td><td style="text-align: center"><code>if 's.is_counting { s.cnt + 1 } else { s.cnt }</code></td></tr>
<tr><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>¬s.is_counting</code></td><td style="text-align: center"><code>if 's.is_counting { s.cnt + 1 } else { s.cnt }</code></td></tr>
<tr><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>s.is_counting</code></td><td style="text-align: center"><code>0</code></td></tr>
<tr><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>¬s.is_counting</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
<p>So, there are <strong>at most</strong> four potential successors to any state <code>s</code>, depending on the
(unconstrained) values of the two inputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smt-and-transition-systems"><a class="header" href="#smt-and-transition-systems">SMT and Transition Systems</a></h1>
<p>Time to use Z3 again: let's try to <code>assert</code> our transition relation so that we can use Z3 to answer
questions about the system. To do this, we need to write our transition relation in <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a>.</p>
<p><br />
</p>
<p>There's two new aspects of <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> that will make things easier for us. First, SMT-LIB
identifiers can be <em>quoted</em> which means they can have form <code>|...|</code> where <code>...</code> is a sequence of
pretty much any character but <code>|</code>. This is convenient as it allows us to write, for example,
identifiers such as <code>|s'.is_counting|</code>. This will make things more readable, hopefully.</p>
<p>Second, <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> allows us to <em>define functions</em> using the <code>define-fun</code> command. Its
shape is</p>
<pre><code class="language-text">(define-fun &lt;ident&gt; ( &lt;args&gt; ) &lt;type&gt;
	&lt;expression&gt;
)
</code></pre>
<p>where <code>&lt;args&gt;</code> is zero or more arguments <code>(&lt;ident&gt; &lt;type&gt;)</code>. For example:</p>
<pre><code class="language-text">(define-fun add_1 ( (n Int) ) Int
	(+ n 1)
)
(define-fun is_even ( (n Int) ) Bool
	(= (mod n 2) 0)
)

(declare-const n Int)
(assert
	(is_even (add_1 n))
)

; Is there an `n` such that `n + 1` is even? (yes)
(check-sat)
(get-model)
</code></pre>
<p>Running Z3, we obtain</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun n () Int
    (- 1))
)
</code></pre>
<p><br />
</p>
<p>So, let's define a function for our transition relation. The definition is a bit daunting because,
again, <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> is really designed to be parsed by solvers. Human readability is not
the main concern, but relatively small examples are quite readable if indented properly.</p>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)
</code></pre>
<blockquote>
<p>Full code in the <a href="trans_smt/index.html#version-1">Version 1</a> section below.</p>
</blockquote>
<p><br />
</p>
<p>Now, if we want to use this transition relation function, we need to give ourselves actual state
variables to apply it to. Let's switch notation to prepare for the more complex manipulations we
will soon investigate. Let's distinguish state variables using indices: instead of referring to <code>s</code>
and <code>s'</code> to distinguish between <em>previous</em> and <em>next</em> state, let's just say we have a state of
index <code>0</code> and another one of index <code>1</code>. So, instead of writing <code>s.cnt</code> and <code>s'.cnt</code> we can just
write <code>cnt_0</code> and <code>cnt_1</code> respectively.</p>
<pre><code class="language-text">; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
</code></pre>
<p>We can now <code>assert</code> our <code>trans</code>ition relation over these two states, <em>i.e.</em> force state <code>1</code> to be a
successor of state <code>0</code>.</p>
<pre><code class="language-text">(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))
</code></pre>
<p>Nice 😸. Let's see if we can force state <code>0</code> and the inputs of state <code>1</code> to have Z3 produce a new
state that's a successor of state <code>0</code>. For instance,</p>
<ul>
<li>state <code>0</code>: <code>cnt</code> is strictly greater than <code>7</code> and <code>is_counting</code> is <code>false</code>;</li>
<li>state <code>1</code>: <code>start_stop</code> is pressed and <code>reset</code> is not.</li>
</ul>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    start_stop_1
    (not reset_1)
))

(check-sat)
(get-model)
</code></pre>
<p><br />
</p>
<p>The <code>check-sat</code> command asks Z3 whether there exists a valuation of all state variables verifying
all our constraints. Said constraints include that state <code>1</code> must be a legal successor of state <code>0</code>.</p>
<blockquote>
<p>Full code in the <a href="trans_smt/index.html#version-1">Version 1</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun cnt_0 () Int
    8)
  (define-fun reset_1 () Bool
    false)
  (define-fun start_stop_1 () Bool
    true)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun cnt_1 () Int
    9)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
<p>It works. In this <em>model</em> (yours might differ), Z3 decided to have <code>cnt_0</code> be <code>8</code> which, given all
the constraints, means that <code>cnt_1</code> is <code>9</code>. This is because <code>is_counting_1</code> is <code>true</code>, which is a
consequence of the last assertion we wrote (<code>is_counting_0</code> is <code>false</code> and <code>start_stop_1</code> is
<code>true</code>).</p>
<p><br />
</p>
<p>Maybe we can ask for something more interesting, <em>i.e.</em> maybe we can actually <strong>prove</strong> something.
Let's modify our last assertion: we keep the constraints over state <code>0</code> and replace state <code>1</code>'s by
<code>cnt_1</code> must be <code>0</code>.</p>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
))

(check-sat)
(get-model)
</code></pre>
<blockquote>
<p>Note that this assertion <strong>replaces</strong> the one above where we constrained state <code>1</code>'s
inputs.</p>
</blockquote>
<p>The question we are asking Z3 is now <em>&quot;say <code>cnt &gt; 7</code> and we're not counting; is it possible then to
have <code>cnt = 0</code> in one transition?&quot;</em>.</p>
<blockquote>
<p>Full code in the <a href="trans_smt/index.html#version-2">Version 2</a> section below.</p>
</blockquote>
<pre><code class="language-text">sat
(
  (define-fun start_stop_1 () Bool
    true)
  (define-fun reset_1 () Bool
    true)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun cnt_0 () Int
    8)
  (define-fun cnt_1 () Int
    0)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
<p>Z3 answers <em>&quot;yes&quot;</em> (<code>sat</code>), and shows us that by pressing <code>reset</code> in state <code>1</code>, then we have <code>cnt = 0</code>. That's fair, but what if we don't allow <code>reset</code> to be pressed in state <code>1</code>?</p>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
    (not reset_1)
))

(check-sat)
</code></pre>
<p>Readers comfortable with our toy stopwatch system know this should not be possible. If <code>reset</code> is
not pressed, <code>cnt</code> can only increase or stay the same depending on whether the system is counting.</p>
<p>Humans (us) <em>&quot;knowing&quot;</em> this is not possible is not very valuable, as humans are notoriously great
at being wrong. Let's just ask Z3 to prove (or disprove) what we <em>know</em>.</p>
<blockquote>
<p>Full code in the <a href="trans_smt/index.html#version-1">Version 1</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
<p>So, Z3's answer is that <em>&quot;there exists no valuation of the state variables verifying these
constraints&quot;</em>. That is, given the constraints on state <code>0</code>, it is not possible to reach a state
where <code>cnt = 0</code> and <code>reset</code> is not pressed in one transition.</p>
<p><br />
</p>
<p>We can see this result as a consequence of a more abstract <em>property</em> of the system. That is, there
are only three possible <code>cnt</code> values in the successor of any given state. Given <code>cnt_0</code>, <code>cnt_1</code>
can only be <code>0</code>, <code>cnt_0</code>, or <code>cnt_0 + 1</code>.</p>
<p><strong>Exercise</strong>: have Z3 prove this property by rewriting the last assertion of <a href="trans_smt/index.html#version-3">Version
3</a>. Check out <a href="trans_smt/index.html#version-4">Version 4</a> for the solution. <strong>Hint below.</strong></p>
<details>
	<summary>Hint.</summary>
<p>Another way to look at what we want to prove is to say <em>&quot;it is not possible for <code>cnt_1</code> to be
anything else than <code>0</code>, <code>cnt_0</code>, or <code>cnt_0 + 1</code>&quot;</em>.</p>
<p>So, if we ask Z3 for a model where <code>cnt_1</code> is none of these and the answer is <code>unsat</code>, then we
would prove that <code>cnt_1</code> cannot be anything but one of these three (not necessarily distinct)
values.</p>
</details>
<p><br />
</p>
<h3 id="full-code-for-all-examples"><a class="header" href="#full-code-for-all-examples">Full Code For All Examples</a></h3>
<h4 id="version-1"><a class="header" href="#version-1">Version 1</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    start_stop_1
    (not reset_1)
))

(check-sat)
(get-model)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun cnt_0 () Int
    8)
  (define-fun reset_1 () Bool
    false)
  (define-fun start_stop_1 () Bool
    true)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun cnt_1 () Int
    9)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
</details>
<h4 id="version-2"><a class="header" href="#version-2">Version 2</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
))

(check-sat)
(get-model)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun start_stop_1 () Bool
    true)
  (define-fun reset_1 () Bool
    true)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun cnt_0 () Int
    8)
  (define-fun cnt_1 () Int
    0)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
</details>
<h4 id="version-3"><a class="header" href="#version-3">Version 3</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
    (not reset_1)
))

(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<h4 id="version-4"><a class="header" href="#version-4">Version 4</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert
    ; negate what we want to prove
    (not
        ; three possible values for `cnt_1` (not necessarily different)
        (or
            (= cnt_1 0)
            (= cnt_1 cnt_0)
            (= cnt_1 (+ cnt_0 1))
        )
    )
)

(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unrolling-and-bmc"><a class="header" href="#unrolling-and-bmc">Unrolling and BMC</a></h1>
<blockquote>
<p>Here we finally start doing things. We will perform a kind of analysis called BMC. While not a
proof technique in general, it is a very useful <em>falsification</em> technique and paves the way
towards <em>induction</em>.</p>
</blockquote>
<p>In the previous chapter, we played with our running example using Z3 by</p>
<ul>
<li>defining the transition relation as a <code>define-fun</code>,</li>
</ul>
<details>
	<summary>Expand for a refresher on this definition.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)
</code></pre>
</details>
<ul>
<li>declaring two states <code>0</code> and <code>1</code>,</li>
</ul>
<details>
	<summary>Expand for a refresher on these declarations.</summary>
<pre><code class="language-text">; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
</code></pre>
</details>
<ul>
<li>asserting the transition relation between state <code>0</code> and state <code>1</code>, and</li>
</ul>
<details>
	<summary>Expand for a refresher on this assertion.</summary>
<pre><code class="language-text">(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))
</code></pre>
</details>
<ul>
<li>querying Z3 by constraining state <code>0</code> and/or state <code>1</code> to inspect the transition relation and
prove some basic properties over it.</li>
</ul>
<details>
	<summary>Expand for the last assertion and the queries.</summary>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    start_stop_1
    (not reset_1)
))

(check-sat)
(get-model)
</code></pre>
</details>
<p><br />
</p>
<h2 id="unrolling"><a class="header" href="#unrolling">Unrolling</a></h2>
<p>Now, this process of asserting the transition relation between two states <code>0</code> and <code>1</code> effectively
enforces the constraint that state <code>1</code> must be a legal successor of state <code>0</code>. This process is
called <em>unrolling the transition relation</em>, or <em>unrolling the system</em>, or just <em>unrolling</em>.</p>
<p>So far, we have only unrolled once to relate state <code>0</code> and state <code>1</code>. We can unroll more than once,
simply by declaring more states and relate <code>0</code> to <code>1</code>, <code>1</code> to <code>2</code>, <em>etc.</em> by asserting the
transition relation over the appropriate state variables.</p>
<details>
	<summary>Expand for an example of unrolling the system thrice.</summary>
<pre><code class="language-text">; ANCHOR: all
; ANCHOR: trans_def
(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)
; ANCHOR_END: trans_def

; ANCHOR: states_def
; State 0.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; State 1.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
; State 2.
(declare-const start_stop_2 Bool)
(declare-const reset_2 Bool)
(declare-const is_counting_2 Bool)
(declare-const cnt_2 Int)
; State 3.
(declare-const start_stop_3 Bool)
(declare-const reset_3 Bool)
(declare-const is_counting_3 Bool)
(declare-const cnt_3 Int)
; ANCHOR_END: states_def

; ANCHOR: unroll_1
(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))
(assert (trans
    start_stop_1 reset_1 is_counting_1 cnt_1
    start_stop_2 reset_2 is_counting_2 cnt_2
))
(assert (trans
    start_stop_2 reset_2 is_counting_2 cnt_2
    start_stop_3 reset_3 is_counting_3 cnt_3
))
; ANCHOR_END: unroll_1

; ANCHOR: state_constraints
(assert (and
    ; starting from `cnt &gt; 7`,
    (&gt; cnt_0 7)
    ; can we reach a state where `cnt = 5` in three transitions?
    (= cnt_3 5)
))

(check-sat)
; ANCHOR_END: state_constraints
; ANCHOR_END: all
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<p><br />
</p>
<h2 id="reachability"><a class="header" href="#reachability">Reachability</a></h2>
<p>Before we actually get to BMC, let's define a few notions. Remember that transition systems have
state variables, and that a <em>state</em> is a valuation of all these state variables. Let's say a state
<code>s</code> is <em>reachable</em> if the system, starting from one of its initial states, can reach <code>s</code> by
applying its transition relation <code>n</code> times, where <code>n</code> is an arbitrary natural number.</p>
<blockquote>
<p>Note that <code>n</code> can be <code>0</code>, <em>i.e.</em> the initial states of a system are reachable, naturally.</p>
</blockquote>
<p>This notion of <em>reachability</em> is usually extended to apply to state predicates. For instance, in
the stopwatch system, we can say that the state predicate <code>cnt &gt; 5</code> is reachable: just start from
<code>0</code> and keep counting.</p>
<p><br />
</p>
<p>Using this notion, we can talk about the set of all reachable states for a given system, called its
<em>reachable state space</em>. This set can be infinite, and even when it's not, actually constructing
this set for realistic systems tends to be impractical. A tool that tries to construct this set is
called <em>explicit-state</em>. SMT-based approaches are almost always <em>implicit-state</em>, as SMT solvers
reason at theory-level about booleans, integers... directly to assess whether a given formula is
satisfiable. The only time actual values (and thus states) are produced is when the formula is
satisfiable and we ask for a model.</p>
<blockquote>
<p>While generally inefficient, tools such as <a href="https://lamport.azurewebsites.net/tla/tla.html" title="TLA+ website">TLA+</a> do manage to scale the explicit-state approach
to impressively large systems. Also, it should be noted that when such a tool manages to
terminate, <em>i.e.</em> compute the entire reachable state space, they are able to (dis)prove
properties that are much more complex than anything we will do here. <a href="https://lamport.azurewebsites.net/tla/tla.html" title="TLA+ website">TLA+</a> for instance can
reason about <em>linear temporal logic</em> formulas which are far beyond the scope of this book.</p>
</blockquote>
<p><br />
</p>
<p>Let's introduce one more notion, that of <em>invariants</em>. Given some transition system, we can write
down a state predicate (such as <code>cnt ≥ 0</code>) and wonder whether it <em>holds</em> (evaluates to <code>true</code>) on
all reachable states. If it does, then that state predicate is an <em>invariant</em> of the system, or
<em>holds</em> for the system.</p>
<p>From now on, we will be interested in transition systems with some <em>candidate invariants</em>. That is,
we will have <em>&quot;properties&quot;</em> and we will have to (dis)prove that they are invariants for the system.
We will say a system is <em>safe</em> if all the candidate invariants are actually invariants. Otherwise,
the system is <em>unsafe</em>.</p>
<p><br />
</p>
<h2 id="fantastic-counterexamples-and-how-to-find-them"><a class="header" href="#fantastic-counterexamples-and-how-to-find-them">Fantastic Counterexamples and How to Find Them</a></h2>
<p>When a candidate invariant <code>I</code> is not an actual invariant, it means there is <em>at least</em> one
reachable state <code>s</code> that <em>falsifies</em> <code>I</code>, <em>i.e.</em> <code>I(s)</code> evaluates to <code>false</code>. Since <code>s</code> is
a reachable state, it means that there exists a trace of states <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> such that</p>
<ul>
<li><code>s_0</code> is an initial state, meaning <code>init(s_0)</code> is <code>true</code>,</li>
<li><code>∀ i ∈ [0, n[</code>, <code>s_i+1</code> is a successor of <code>s_i</code>, meaning <code>trans(s_i, s_i+1)</code> is <code>true</code>, and</li>
<li><code>s_n = s</code>, meaning <code>I(s_n)</code> is <code>false</code>.</li>
</ul>
<p>Assuming we are reporting to someone/something, we want to do better than just say <code>unsafe</code> when a
candidate invariant does not hold for the system. Ideally, we should produce a witness of the
candidate's falsification: a <em>counterexample</em>, which would be a trace of succeeding states leading
to a state falsifying the candidate.</p>
<p><br />
</p>
<p>Thankfully, we have an SMT solver to do this. Can we actually explore the reachable state space and
look for a falsification given what we have seen so far?</p>
<p>A first approach to doing this would be to write a bunch of assertions that are satisfiable if and
only if there exists such a counterexample trace of some arbitrary length. Unfortunately, we cannot
really do this as unrolling is a manual process: we declare state <code>i</code>, then assert the relation
between state <code>i-1</code> and state <code>i</code>. We cannot write a finite number of assertions that encode an
arbitrary number of unrollings for the SMT solver to reason about. You can go ahead and try it, but
it will not work. At least not without quantifiers (<code>∀</code>, <code>∃</code>), which would not scale well at all.</p>
<p><br />
</p>
<p>Now that we are frustrated by this dead-end approach, let's forget about our ideal goal and try
tackle something simpler: can we look for a falsification of the candidate invariants in the
initial states?</p>
<p>Let's get back to our running stopwatch example, and add a candidate invariant: <code>cnt ≥ 0</code>. Recall
that the stopwatch's initial predicate is</p>
<pre><code class="language-text">init(s) ≜ (s.reset ⇒ s.cnt = 0) ∧ (s.is_counting = s.start_stop)
</code></pre>
<p><br />
</p>
<p>Now, we need to design some assertions for the SMT solver such that they are satisfiable if and
only if there exists an initial state that falsifies our candidate. This is quite similar to the
unrolling we did in the previous chapter, where we wrote assertions that were satisfiable if and
only if state <code>1</code> was a successor of state <code>0</code>, and <code>cnt_1</code> was something else than <code>0</code>, <code>cnt_0</code> or
<code>cnt_0 + 1</code>.</p>
<p>Following the same approach, we first need to <code>define-fun</code> our initial state predicate.</p>
<pre><code class="language-text">(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
    )
)
</code></pre>
<p>That was easy. Next up, declare a state so that we can assert <code>init</code> on it.</p>
<pre><code class="language-text">(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
</code></pre>
<p>Then we write the <code>init</code> assertion.</p>
<pre><code class="language-text">(assert
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
)
</code></pre>
<p>So easy. We want the SMT solver to look for a falsification of our candidate <code>cnt ≥ 0</code>, so we just
assert that.</p>
<pre><code class="language-text">(assert
    (not (&gt;= cnt_0 0))
)

(check-sat)
(get-model)
</code></pre>
<p>If Z3 answers <code>sat</code> to these constraints, it means it found some values for the state variables
such that they</p>
<ul>
<li>represent an actual initial state, and</li>
<li>falsify our candidate.</li>
</ul>
<blockquote>
<p>Full code in the <a href="bmc/index.html#version-1">Version 1</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun reset_0 () Bool
    false)
  (define-fun cnt_0 () Int
    (- 1))
  (define-fun start_stop_0 () Bool
    false)
  (define-fun is_counting_0 () Bool
    false)
)
</code></pre>
<p>Did it work? Let's look at our initial predicate again:</p>
<pre><code class="language-text">init(s) ≜ (s.reset ⇒ s.cnt = 0) ∧ (s.is_counting = s.start_stop)
</code></pre>
<p>The specification of the system did not really say anything about the initial value <code>cnt</code> should
have. At least not besides the fact that it should be <code>0</code> when <code>reset</code> is <code>true</code>. Hence, when
<code>reset</code> is <code>false</code>, <code>cnt</code> is not constrained in any way. In a real program, one could see this as a
<em>use-before-init</em> problem where we declare (but not initialize) a <code>cnt</code> variable, set it to <code>0</code> if
<code>reset</code> is <code>true</code>, but do nothing otherwise: <code>cnt</code> could be anything (including an invalid integer).</p>
<p><br />
</p>
<p>So our system is unsafe: the candidate does not hold. The specification was not precise enough.
Let's say from now on that the specification tells us <em><code>cnt</code> is initially an arbitrary positive
integer</em>. Let's fix our initial predicate.</p>
<pre><code class="language-text">(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
;       ^^^^^^^^^^^^^^~~~~ fixed the specification
    )
)
</code></pre>
<p>We do not need to change anything else, we can just run the same check on the updated initial
predicate.</p>
<blockquote>
<p>Full code in the <a href="bmc/index.html#version-2">Version 2</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
<p>Perfect: by answering <code>unsat</code>, Z3 is telling us that it proved that no valuation of <code>s_0</code> is such
that it is an initial state and it falsifies the candidate invariant. We just proved something: no
falsification of the candidate is reachable in <code>0</code> transitions. Nice.</p>
<p>Can we keep going? Is the candidate falsifiable in <code>1</code> transitions, or <code>7</code>, or more? Of course we
can, thanks to unrolling. We previously used unrolling to start from some arbitrary state <code>s_0</code> and
perform checks about its potential successor(s). If we just force <code>s_0</code> to be initial, like we just
did, we can then unroll once to ask Z3 whether a successor <code>s_1</code> of <code>s_0</code> can falsify the
candidate. If not, we can unroll once more, and so on until we find a falsification.</p>
<p>Congratulations to us, we just invented BMC.</p>
<p><br />
</p>
<blockquote>
<p>The stopwatch system has an infinite reachable state space since <code>cnt</code> can reach any integer
value (just keep incrementing it). Start actually proving candidates in the next chapter, this
one focuses solely on finding counterexamples.</p>
</blockquote>
<p><br />
</p>
<h2 id="bmc"><a class="header" href="#bmc">BMC</a></h2>
<p><strong>B</strong>ounded <strong>M</strong>odel-<strong>C</strong>hecking (BMC) is a <em>forward exploration</em> of the reachable state space of
a transition system. The term <em>forward exploration</em> refers to the fact that BMC starts from the
initial states and explores the state space by unrolling the transition relation incrementally.</p>
<p>As a technique <strong>B</strong>MC is explicitly <em>bounded</em>: it explores the reachable state space <strong>up to
some</strong> depth (number of unrollings). That is, as long as the reachable state space is infinite, BMC
cannot prove anything because it will never finish exploring the state space. All it can do is
<em>disprove</em> candidates.</p>
<p><br />
</p>
<p>By this point, I expect most readers to be able to write SMT-LIB code that corresponds to a BMC
check for a given number of unrollings. Just to make sure, the <a href="bmc/index.html#bmc-with-unrolling">BMC with
Unrolling</a> section showcases a BMC check where the transition relation is
unrolled twice.</p>
<p><br />
</p>
<blockquote>
<p><strong>Warning:</strong> slightly (more) technical and practical discussion ahead. What follows is not
mandatory to understand the upcoming chapters, but I think it is quite interesting and definitely
mandatory for writing your own (efficient) verification engine.</p>
</blockquote>
<p><br />
</p>
<p>Let's discuss a few practical points regarding BMC. Mainly, the fact that it is incremental and
that what we do at a given step depends on the solver's previous answer. For instance, say we have
several candidate invariants and we are checking whether we can falsify some of them by unrolling
<code>k</code> times. Say also the solver answers yes (<code>sat</code>) and gives us a model. Then what we want to do is
check which candidates are falsified (using the model), and keep BMC-ing the candidates that were
not falsified. We got a counterexample for some of the candidates, but there might be a different
counterexample at the same depth falsifying other candidates. If not (<code>unsat</code>), we move on and
check the remaining candidates at <code>k+1</code> and so on. Maybe they can be falsified by unrolling more
than <code>k</code> times.</p>
<p>So, this whole process is interactive: what BMC does depends on what the solver previously said. In
the next chapter, I will introduce mikino which is a tool that will perform BMC (and more) for us.
The way mikino conducts BMC is by launching Z3 as a separate process and feed it definitions,
declarations, assertions, <code>check-sat</code>s and <code>get-model</code>s on its standard input. Z3 produces answers
on its standard output, which mikino looks at to decide if/how to continue and what to stream to
the input of the Z3 process.</p>
<p><br />
</p>
<p>Based on what we have done so far, this would require restarting the solver each time. Say Z3
answers <code>unsat</code> when we unroll <code>k</code> times. It means that we have an assertion of the negation of the
candidate(s) for <code>s_k</code> which made our whole SMT-LIB instance (all the assertions together) <code>unsat</code>:
<code>(assert (not (candidate s_k)))</code>. Now, this assertion is only there for our check at depth <code>k</code>, to
ask for a falsification of the candidate(s). Still, we cannot move on and unroll at <code>k+1</code>: this
assertion will still be there, and the instance will remain <code>unsat</code>.</p>
<p>So, instead of restarting Z3, we can make the assertion of the negation of the candidates
conditional. That is, we can give ourselves a <em>boolean flag</em> that <em>activates</em> this assertion.
Such a flag is called an <em>activation literal</em>, or <em>actlit</em>.</p>
<p>Say we are performing a BMC check at depth <code>k</code>. First, we need to declare this <em>&quot;boolean flag&quot;</em>.</p>
<pre><code class="language-text">(declare-const actlit_k Bool)
</code></pre>
<p>Next, we write our assertion of the negation of the candidate(s) in such a way that <code>actlit_k</code>
needs to be true for the assertion to be active.</p>
<pre><code class="language-text">(assert
	(=&gt; actlit_k
		(not (and (candidate_1 s_k) (candidate_2 s_k) ...))
	)
)
</code></pre>
<p>Notice that if <code>actlit_k</code> is <code>false</code>, then this assertion is trivially <code>true</code> and thus does not
contribute to whether other assertions are satisfiable. This is because <code>false ⇒ P</code> is always
<code>true</code>, regardless of what <code>P</code> is. In particular, <code>false ⇒ false</code> is true.</p>
<p>The last thing we need now is to perform a <code>check-sat</code> <em>assuming</em> <code>actlit_k</code> is true. We could
<code>(assert actlit_k)</code> but that would not solve our problem: we cannot go back and <em>undo</em> this
assertion, hence the negation of the candidates is active, hence the whole instance is <code>unsat</code>.</p>
<p><br />
</p>
<p>Instead, we can use the <code>check-sat-assuming</code> SMT-LIB command. This command takes a list of boolean
variables and forces to <code>check-sat</code> our assertions <strong>assuming</strong> these variables are <code>true</code>, but
<strong>without</strong> actually asserting them. Meaning that, after the check-sat, these variables are still
unconstrained.</p>
<p>In particular, it means we can perform a <code>check-sat-assuming</code> on <code>actlit_k</code>, and then just assert
<code>actlit_k</code> to be false to effectively deactivate the assertion of the negation of the candidates.</p>
<p><br />
</p>
<p>This is all a bit abstract, let's see it in action on the stopwatch system. The <a href="bmc/index.html#bmc-with-unrolling">BMC with
Unrolling</a> section shows an unrolling of the system at depth <code>2</code> with the
corresponding check for candidate <code>cnt ≥ 0</code>, and just that check. Let's modify it so that it uses
activation literals to perform all checks up to depth <code>2</code>.</p>
<p>The first check to perform is at depth <code>0</code>, so all we asserted so far is that state <code>0</code> is initial.</p>
<pre><code class="language-text">; State 0 is initial.
(assert
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
)
</code></pre>
<p>Next we declare our activation literal for the upcoming check.</p>
<pre><code class="language-text">; Activation literal for the first check.
(declare-const actlit_0 Bool)
</code></pre>
<p>Then we conditionally assert the negation of the candidate.</p>
<pre><code class="language-text">; Conditional assertion of the negation of the candidate at 0.
(assert (=&gt; actlit_0
    (not (&gt;= cnt_0 0))
))
</code></pre>
<p>Then comes the check itself, using the brand new <code>check-sat-assuming</code> command we just discussed.</p>
<pre><code class="language-text">; Check-sat, assuming `actlit_0` is true.
(echo &quot;; info: falsification at depth 0?&quot;)
(check-sat-assuming ( actlit_0 ))
</code></pre>
<p>Notice the use of the <code>echo</code> command which takes a string and causes the solver to output said
string to its standard output. Remember that we will perform more than one check, so we use <code>echo</code>
to keep track of what question the <code>sat</code>/<code>unsat</code> answers are for.</p>
<p>As we already saw, this check will produce <code>unsat</code>: there is no falsification of this candidate at
depth <code>0</code> (or at any depth, but we have not proved that yet).</p>
<pre><code class="language-text">; Solver answers `unsat`, we want to unroll the system some more.
; Before we do that, we deactivate the actlit.
(assert (not actlit_0))
; At this point, the solver realized the conditional assertion
; of the negation of the candidate is trivially `true`, and will
; ignore it from now on.
</code></pre>
<p>As a sanity check, we can <code>check-sat</code> right after we deactivated <code>actlit_0</code>. We just got an <code>unsat</code>
because we assumed <code>actlit_0</code>, so if the deactivation of the negation of the candidate failed then
a regular <code>check-sat</code> would also yield <code>unsat</code>. If deactivation worked, we should get <code>sat</code> because
<code>(init s_0)</code>, our only active assertion, is <code>sat</code>.</p>
<pre><code class="language-text">(echo &quot;; info: making sure assertion at 0 is not active anymore, expecting `sat`&quot;)
(check-sat)
</code></pre>
<p>We can now keep on unrolling and <code>check-sat-assuming</code>, since the assertion of the negation of the
candidate should now be deactivated.</p>
<pre><code class="language-text">(assert
    (trans
        start_stop_0 reset_0 is_counting_0 cnt_0
        start_stop_1 reset_1 is_counting_1 cnt_1
    )
)
(declare-const actlit_1 Bool)
(assert (=&gt; actlit_1
    (not (&gt;= cnt_1 0))
))
(echo &quot;; info: falsification at depth 1?&quot;)
(check-sat-assuming ( actlit_1 ))
(assert (not actlit_1))
(echo &quot;; info: making sure assertion at 1 is not active anymore, expecting `sat`&quot;)
(check-sat)
</code></pre>
<p>We can keep going like that for as long as we want. Running Z3 on SMT-LIB code enforcing this
methodology up to depth <code>2</code> produces the following output (see the <a href="bmc/index.html#bmc-with-actlits">BMC with
Actlits</a> section below for the full code).</p>
<pre><code class="language-text">; info: falsification at depth 0?
unsat
; info: making sure assertion at 0 is not active anymore, expecting `sat`
sat
; info: falsification at depth 1?
unsat
; info: making sure assertion at 1 is not active anymore, expecting `sat`
sat
; info: falsification at depth 2?
unsat
; info: making sure assertion at 2 is not active anymore, expecting `sat`
sat
</code></pre>
<p>Pretty nice 😸. Let's never do this again manually to preserve our own sanity, and move on to the
next chapter where we will introduce mikino to do all of this automatically.</p>
<h3 id="full-code-for-all-examples-1"><a class="header" href="#full-code-for-all-examples-1">Full Code For All Examples</a></h3>
<h4 id="version-1-1"><a class="header" href="#version-1-1">Version 1</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
    )
)

(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)

(assert
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
)

(assert
    (not (&gt;= cnt_0 0))
)

(check-sat)
(get-model)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun reset_0 () Bool
    false)
  (define-fun cnt_0 () Int
    (- 1))
  (define-fun start_stop_0 () Bool
    false)
  (define-fun is_counting_0 () Bool
    false)
)
</code></pre>
</details>
<h4 id="version-2-1"><a class="header" href="#version-2-1">Version 2</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
;       ^^^^^^^^^^^^^^~~~~ fixed the specification
    )
)

(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)

(assert
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
)

(assert
    (not (&gt;= cnt_0 0))
)

(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<h4 id="bmc-with-unrolling"><a class="header" href="#bmc-with-unrolling">BMC with Unrolling</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">; Initial predicate.
(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
    )
)

; Transition relation.
(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; State 0.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; State 1.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
; State 2.
(declare-const start_stop_2 Bool)
(declare-const reset_2 Bool)
(declare-const is_counting_2 Bool)
(declare-const cnt_2 Int)

; State 0 is initial.
(assert
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
)

; State 1 is a successor of state 0.
(assert
    (trans
        start_stop_0 reset_0 is_counting_0 cnt_0
        start_stop_1 reset_1 is_counting_1 cnt_1
    )
)

; State 2 is a successor of state 1.
(assert
    (trans
        start_stop_1 reset_1 is_counting_1 cnt_1
        start_stop_2 reset_2 is_counting_2 cnt_2
    )
)

; State 2 must falsify the candidate.
(assert
    (not (&gt;= cnt_2 0))
)

; Is this possible?
(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<h4 id="bmc-with-actlits"><a class="header" href="#bmc-with-actlits">BMC with Actlits</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">; Initial predicate.
(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
    )
)

; Transition relation.
(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; State 0.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; State 1.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
; State 2.
(declare-const start_stop_2 Bool)
(declare-const reset_2 Bool)
(declare-const is_counting_2 Bool)
(declare-const cnt_2 Int)

; State 0 is initial.
(assert
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
)

; Activation literal for the first check.
(declare-const actlit_0 Bool)
; Conditional assertion of the negation of the candidate at 0.
(assert (=&gt; actlit_0
    (not (&gt;= cnt_0 0))
))
; Check-sat, assuming `actlit_0` is true.
(echo &quot;; info: falsification at depth 0?&quot;)
(check-sat-assuming ( actlit_0 ))
; Solver answers `unsat`, we want to unroll the system some more.
; Before we do that, we deactivate the actlit.
(assert (not actlit_0))
; At this point, the solver realized the conditional assertion
; of the negation of the candidate is trivially `true`, and will
; ignore it from now on.

(echo &quot;; info: making sure assertion at 0 is not active anymore, expecting `sat`&quot;)
(check-sat)

(assert
    (trans
        start_stop_0 reset_0 is_counting_0 cnt_0
        start_stop_1 reset_1 is_counting_1 cnt_1
    )
)
(declare-const actlit_1 Bool)
(assert (=&gt; actlit_1
    (not (&gt;= cnt_1 0))
))
(echo &quot;; info: falsification at depth 1?&quot;)
(check-sat-assuming ( actlit_1 ))
(assert (not actlit_1))
(echo &quot;; info: making sure assertion at 1 is not active anymore, expecting `sat`&quot;)
(check-sat)

(assert
    (trans
        start_stop_1 reset_1 is_counting_1 cnt_1
        start_stop_2 reset_2 is_counting_2 cnt_2
    )
)
(declare-const actlit_2 Bool)
(assert (=&gt; actlit_2
    (not (&gt;= cnt_2 0))
))
(echo &quot;; info: falsification at depth 2?&quot;)
(check-sat-assuming ( actlit_2 ))
(assert (not actlit_2))
(echo &quot;; info: making sure assertion at 2 is not active anymore, expecting `sat`&quot;)
(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
; info: falsification at depth 0?
unsat
; info: making sure assertion at 0 is not active anymore, expecting `sat`
sat
; info: falsification at depth 1?
unsat
; info: making sure assertion at 1 is not active anymore, expecting `sat`
sat
; info: falsification at depth 2?
unsat
; info: making sure assertion at 2 is not active anymore, expecting `sat`
sat
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bmc-mikino"><a class="header" href="#bmc-mikino">BMC: Mikino</a></h1>
<p><a href="https://github.com/OCamlPro/mikino_bin" title="Mikino on github">Mikino</a> is a small transition system verification engine that relies on SMT solvers and
everything we have seen so far (and will see later). It is designed to be relatively simple with
user experience front and center: the goal is to have a tool that is gratifying to interact with to
teach about induction-based verification.</p>
<p>Most examples from this point will rely on mikino, so I encourage you to install it so that you can
mess around with my examples and get a better understanding. See the <a href="mikino_bmc/../mikino_install">mikino
appendix</a> for setup instructions.</p>
<p><br />
</p>
<h2 id="input-format"><a class="header" href="#input-format">Input Format</a></h2>
<p>Mikino takes as input a transition system in a format consistent but slightly different from what
we have seen up to this point. Systems are written in files organized as follows, illustrated on
our stopwatch running example.</p>
<p>First are state variable declarations. It is a list of declarations between braces introduced by
the <code>svars</code> keyword and of form <code>&lt;var_1&gt; &lt;var_2&gt; ... &lt;var_n&gt;: &lt;type&gt;</code> with <code>n ≥ 1</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// State variables.
svars {
	/// Inputs of the system.
	start_stop reset: bool,
	/// Keeps track of whether we are counting.
	is_counting: bool,
	/// Counts time, output of the system.
	cnt: int,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next is the initial predicate, introduced by the <code>init</code> keyword. Mikino does not support
SMT-LIB-2-like (s-)expressions (anymore), and instead expects Rust-like expressions. Note that
mikino supports common unicode operators such as <code>∧</code>, <code>⋀</code>, <code>∨</code>, <code>⋁</code>, <code>≥</code> and <code>⇒</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Initial predicate.
init {
	is_counting = start_stop,
	cnt ≥ 0,
	(reset ⇒ cnt = 0),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Here, we gave <code>init</code> a list of three comma-separated (with optional trailing comma) expressions.
This list is understood as a conjunction <code>⋀</code>, meaning the list above is equivalent to writing
<code>is_counting = start_stop ⋀ cnt ≥ 0 ⋀ (reset ⇒ cnt = 0)</code>.</p>
</blockquote>
<p><br />
</p>
<p>The transition relation definition, introduced by the <code>trans</code> keyword, differs slightly. Remember
that the transition relation relates two states: the <em>previous</em> one and the <em>next</em> one. In mikino,
we refer to the <em>previous</em> version of a state variable <code>svar</code> by simply writing <code>svar</code>. If we want
to refer to its <em>next</em> version, we must use the <code>'</code> (prime) prefix operator: <code>'svar</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Transition relation.
trans {
	// The *next* value of `is_counting` is equal to...
	'is_counting = if 'start_stop {
		// ...if `'start_stop` is true, then the negation of
		// its *previous* value...
		¬is_counting
	} else {
		// ...otherwise, it is equal to its previous value.
		is_counting
	},
	'cnt = if 'reset {
		0
	} else if 'is_counting {
		cnt + 1
	} else {
		cnt
	},
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>trans</code> also accepts a comma-separated list of expressions understood as a <em>conjunction</em> <code>⋀</code>.</p>
</blockquote>
<p><br />
</p>
<p>Last are the candidate invariants, sometimes called <strong>P</strong>roof <strong>O</strong>bjective<strong>s</strong>, introduced by the
<code>candidates</code> keyword. They are given as a comma-separated list of named candidates of shape
<code>&quot;string describing the candidate&quot;: &lt;expr&gt;</code>. The name of a candidate is what mikino will use to
refer to that candidate in its output.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Candidate invariants.
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Mikino's input format is designed to look relatively pretty with Rust syntax highlighting (which
is used in the snippets above). It is definitely not legal Rust syntax though, so make sure
<code>rustfmt</code> does not run on it as it will fail.</p>
</blockquote>
<p><br />
</p>
<h2 id="run-bmc"><a class="header" href="#run-bmc">Run BMC</a></h2>
<p>Mikino is a proof engine, meaning that it can prove invariants over transition systems as we will
see very soon. For now, let's just use its BMC mode. As discussed previously, BMC is not a proof
technique (at least in infinite reachable state spaces), it is a <em>refutation</em> technique: the point
of BMC is to produce counterexamples to candidate invariants thus disproving them.</p>
<p>Let's try mikino on the stopwatch system described above. The full code is available in the
<a href="mikino_bmc/index.html#version-1">Version 1</a> section, the following assumes that code is in a <code>test.mkn</code> file. Notice
that the candidates</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Candidate invariants.
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<p>feature <code>&quot;cnt is positive&quot;</code>, which we will soon prove is an invariant of the system. Hence,
mikino's BMC will not be able to find a counterexample for this candidate. We are thus going to run
BMC with a <em>maximum depth</em>, <em>i.e.</em> we will give mikino a maximum number of unrollings to perform:
<code>10</code>. The remaining candidates however are falsifiable.</p>
<p><br />
</p>
<p>To put mikino in BMC mode, we need to pass it the <code>bmc</code> sub-command when we run it. We will also
use the <code>--bmc_max &lt;int&gt;</code> flag that specifies a maximum BMC unrolling depth <code>≥ 0</code>. If no maximum is
given, mikino will run BMC until either all candidates are falsified or you end (<code>Ctrl+C</code>) the
process manually (or it exhausts memory/time).</p>
<p><br />
</p>
<blockquote>
<p>Mikino requires <a href="https://github.com/Z3Prover/z3" title="Z3 on github">Z3</a> to run, you can retrieve a binary for your operating system on
<a href="https://github.com/Z3Prover/z3/releases" title="Z3's releases on github">Z3's release page</a>. Mikino, by default, assumes a Z3 binary is in your <code>PATH</code> with
name <code>z3</code>. You can override this with the <code>--z3_cmd</code> command-line argument: <code>mikino --z3_cmd &quot;my_z3&quot; ...</code> or <code>mikino --z3_cmd &quot;./my_z3&quot; ...</code> if Z3 is not in your <code>PATH</code> but is in the current
directory.</p>
</blockquote>
<p>Let's try it. Mikino tries to improve its output's readability by using colors: unfortunately, this
will not show in this plain text rendition. (As discussed when I introduced SMT, different versions
of Z3 or even different operating system might produce different models. The same applies to mikino
as its counterexamples are Z3 models.)</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
running BMC, looking for falsifications for 3 candidate(s)...
checking for falsifications at depth 0
found a falsification at depth 0:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step 0
  |         cnt = 3
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=|
found a falsification at depth 0:
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step 0
  |         cnt = 5
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 1
checking for falsifications at depth 2
checking for falsifications at depth 3
checking for falsifications at depth 4
checking for falsifications at depth 5
checking for falsifications at depth 6
checking for falsifications at depth 7
checking for falsifications at depth 8
checking for falsifications at depth 9
checking for falsifications at depth 10

|===| Bmc result
| - could not find falsifications for the following candidate(s)
|   `cnt is positive`
|
| - found a falsification for the following candidate(s)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system is unsafe
|===|
</code></pre>
<blockquote>
<p><strong>Pro tip:</strong> use the <code>--smt_log &lt;DIR&gt;</code> flag to specify a directory where mikino will create an
SMT-LIB 2 file per solver it uses, and log all the commands issued to that solver. For instance,</p>
<pre><code class="language-text">&gt; mikino bmc --smt_log smt_traces --bmc_max 10 test.mkn
&gt; tree smt_traces/
smt_traces
└── bmc.smt2
</code></pre>
<p>This can be useful to inspect the exact checks mikino is performing and modify/relaunch them.</p>
</blockquote>
<p>Mikino incrementally unrolls BMC just like we discussed in the previous chapter. It starts at depth
<code>0</code>, which means <em><code>0</code> transitions away from the initial states</em>, which really means <em>the initial
states</em>. Right away, it falsifies all our candidates but the first one. This is because of our
initial predicate:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Initial predicate.
init {
	is_counting = start_stop,
	cnt ≥ 0,
	(reset ⇒ cnt = 0),
}
<span class="boring">}
</span></code></pre></pre>
<p>The system can start with any value for <code>cnt</code> as long as <em>i)</em> it is positive and <em>ii)</em> <code>reset</code> is
not pressed. Mikino's output makes sense, but can we modify the system so that falsifiable
candidates can only be falsified by unrolling more than <code>0</code> times?</p>
<p>We sure can, by changing <code>init</code> so that <code>cnt</code> always starts at <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Initial predicate.
init {
	is_counting = start_stop,
	cnt = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>We do not need to look at <code>reset</code> anymore since <code>cnt</code> will be <code>0</code> regardless. The full code for
this new version is available in the <a href="mikino_bmc/index.html#version-2">Version 2</a> section. We run mikino in BMC mode
again, and this time we get</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
running BMC, looking for falsifications for 3 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
checking for falsifications at depth 2
checking for falsifications at depth 3
found a falsification at depth 3:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step 0
  |         cnt = 0
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step 1
  |         cnt = 1
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 2
  |         cnt = 2
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 3
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 4
checking for falsifications at depth 5
found a falsification at depth 5:
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step 0
  |         cnt = 0
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step 1
  |         cnt = 1
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 2
  |         cnt = 2
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 3
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 4
  |         cnt = 4
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 5
  |         cnt = 5
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 6
checking for falsifications at depth 7
checking for falsifications at depth 8
checking for falsifications at depth 9
checking for falsifications at depth 10

|===| Bmc result
| - could not find falsifications for the following candidate(s)
|   `cnt is positive`
|
| - found a falsification for the following candidate(s)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system is unsafe
|===|
</code></pre>
<p>Mikino is not able to falsify the falsifiable candidates in the initial states (depth <code>0</code>, <em>i.e.</em>
zero unrollings of the transition relation) anymore, which was the whole point of the modification
to <code>init</code> we just made. Mikino proceeds to check for falsifications at increasing depth. Once it
reaches depth <code>3</code>, a falsification for <code>cnt ≤ 2</code> is found and a counterexample is produced. The
counterexample shows the whole trace, from an initial state to a state falsifying the candidate
because <code>cnt = 3</code> and <code>3 ≤ 2</code> is not <code>true</code>.</p>
<p>Mikino keeps going with the remaining candidates. Although it does not appear in the output, after
finding a counterexample at depth <code>3</code> mikino checks the remaining candidates (without <code>cnt ≤ 2</code>) at
depth <code>3</code>. We got one counterexample for one candidate, but there might be a different
counterexample for another candidate at the same depth.</p>
<p>This is not the case here, and mikino proceeds to unroll the transition relation some more. It
finds another counterexample at depth <code>5</code> for <code>cnt ≤ 4</code> and displays the whole trace, as expected.</p>
<p><br />
</p>
<p>Let's modify our candidates, full code available in the <a href="mikino_bmc/index.html#version-3">Version 3</a> section.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Candidate invariants, or &quot;Proof Objectives&quot; (`po_s`).
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;reset works&quot;: reset ⇒ cnt = 0,
	&quot;is_counting implies cnt &gt; 0&quot;: (is_counting ⋀ ¬start_stop) ⇒ cnt &gt; 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>You can place your bets as to which of these candidates are actual invariants. The third candidate
is a bit strange, we will discuss why it is written that way shortly. Again, BMC cannot prove that
any of them are indeed invariants, but it can disprove some of them if it finds a counterexample at
some depth.</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
running BMC, looking for falsifications for 3 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
found a falsification at depth 1:
- `is_counting implies cnt &gt; 0` = (=&gt; (and is_counting (not start_stop)) (&gt; cnt 0))
  |=| Step 0
  |         cnt = 0
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 1
  |         cnt = 0
  | is_counting = true
  |       reset = true
  |  start_stop = false
  |=|
checking for falsifications at depth 2
checking for falsifications at depth 3
checking for falsifications at depth 4
checking for falsifications at depth 5
checking for falsifications at depth 6
checking for falsifications at depth 7
checking for falsifications at depth 8
checking for falsifications at depth 9
checking for falsifications at depth 10

|===| Bmc result
| - could not find falsifications for the following candidate(s)
|   `cnt is positive`
|   `reset works`
|
| - found a falsification for the following candidate(s)
|   `is_counting implies cnt &gt; 0`
|
| - system is unsafe
|===|
</code></pre>
<p>Candidate <code>is_counting implies cnt &gt; 0</code> was falsified. The idea of this candidate is that, when the
system <code>is_counting</code>, <code>cnt</code> should increase and thus be strictly positive (more on that in the note
below). Mikino shows us this is not true however, because <code>reset</code> has higher priority in our
transition relation and causes <code>cnt</code> to be <code>0</code> regardless of <code>is_counting</code>'s value.</p>
<p><br />
</p>
<blockquote>
<p>We had to somewhat artificially write the candidate as <code>(is_counting ⋀ ¬start_stop) ⇒ cnt &gt; 0</code>.
Based on the paragraph above, the <code>is_counting ⋀ ¬start_stop</code> part should really be
<code>is_counting</code>. The problem with this is that we actually ignore <code>is_counting</code> in the initial
state.</p>
<p>Hence, we would get a initial state counterexample where <code>start_stop</code> is <code>true</code>, meaning
<code>is_counting</code> is <code>true</code>, but <code>cnt</code> ignores it and is just <code>0</code>. As authors, we wanted to show a
counterexample where <code>reset</code> prevents <code>cnt</code> from increasing despite <code>start_stop</code> being <code>true</code>,
and thus had to distort the candidate a little bit.</p>
<p>A better way to write this candidate is <code>is_counting ⇒ 'cnt &gt; cnt</code>. It would still be
falsifiable, for the same reason and with the same counterexample, but it would make more sense.
Sadly, mikino does not <strong>currently</strong> support <em>&quot;two-state candidates&quot;</em>, <em>i.e.</em> candidates that
refer to a <em>previous</em> state.</p>
<p>Checking two-state candidates differs slightly from regular (one-state) candidates in that they
make no sense in the initial states (depth <code>0</code>) because there is no previous state there. Hence,
a two states invariant defined as <code>two_state_expr</code> is understood as being the expression <code>true</code>
in the initial states (which holds, obviously), and <code>two_state_expr</code> at depth <code>&gt; 0</code> since there
is a previous state to refer to.</p>
</blockquote>
<p><br />
</p>
<h2 id="full-code-for-all-examples-2"><a class="header" href="#full-code-for-all-examples-2">Full Code for All Examples</a></h2>
<h3 id="version-1-2"><a class="header" href="#version-1-2">Version 1</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// State variables.
svars {
	/// Inputs of the system.
	start_stop reset: bool,
	/// Keeps track of whether we are counting.
	is_counting: bool,
	/// Counts time, output of the system.
	cnt: int,
}

/// Initial predicate.
init {
	is_counting = start_stop,
	cnt ≥ 0,
	(reset ⇒ cnt = 0),
}

/// Transition relation.
trans {
	// The *next* value of `is_counting` is equal to...
	'is_counting = if 'start_stop {
		// ...if `'start_stop` is true, then the negation of
		// its *previous* value...
		¬is_counting
	} else {
		// ...otherwise, it is equal to its previous value.
		is_counting
	},
	'cnt = if 'reset {
		0
	} else if 'is_counting {
		cnt + 1
	} else {
		cnt
	},
}

/// Candidate invariants.
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
running BMC, looking for falsifications for 3 candidate(s)...
checking for falsifications at depth 0
found a falsification at depth 0:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step 0
  |         cnt = 3
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=|
found a falsification at depth 0:
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step 0
  |         cnt = 5
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 1
checking for falsifications at depth 2
checking for falsifications at depth 3
checking for falsifications at depth 4
checking for falsifications at depth 5
checking for falsifications at depth 6
checking for falsifications at depth 7
checking for falsifications at depth 8
checking for falsifications at depth 9
checking for falsifications at depth 10

|===| Bmc result
| - could not find falsifications for the following candidate(s)
|   `cnt is positive`
|
| - found a falsification for the following candidate(s)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system is unsafe
|===|
</code></pre>
</details>
<h3 id="version-2-2"><a class="header" href="#version-2-2">Version 2</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// State variables.
svars {
	/// Inputs of the system.
	start_stop reset: bool,
	/// Keeps track of whether we are counting.
	is_counting: bool,
	/// Counts time, output of the system.
	cnt: int,
}

/// Initial predicate.
init {
	is_counting = start_stop,
	cnt = 0,
}

/// Transition relation.
trans {
	// The *next* value of `is_counting` is equal to...
	'is_counting = if 'start_stop {
		// ...if `'start_stop` is true, then the negation of
		// its *previous* value...
		¬is_counting
	} else {
		// ...otherwise, it is equal to its previous value.
		is_counting
	},
	'cnt = if 'reset {
		0
	} else if 'is_counting {
		cnt + 1
	} else {
		cnt
	},
}

/// Candidate invariants.
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
running BMC, looking for falsifications for 3 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
checking for falsifications at depth 2
checking for falsifications at depth 3
found a falsification at depth 3:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step 0
  |         cnt = 0
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step 1
  |         cnt = 1
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 2
  |         cnt = 2
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 3
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 4
checking for falsifications at depth 5
found a falsification at depth 5:
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step 0
  |         cnt = 0
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step 1
  |         cnt = 1
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 2
  |         cnt = 2
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 3
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 4
  |         cnt = 4
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 5
  |         cnt = 5
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 6
checking for falsifications at depth 7
checking for falsifications at depth 8
checking for falsifications at depth 9
checking for falsifications at depth 10

|===| Bmc result
| - could not find falsifications for the following candidate(s)
|   `cnt is positive`
|
| - found a falsification for the following candidate(s)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system is unsafe
|===|
</code></pre>
</details>
<h3 id="version-3-1"><a class="header" href="#version-3-1">Version 3</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// State variables.
svars {
	/// Inputs of the system.
	start_stop reset: bool,
	/// Keeps track of whether we are counting.
	is_counting: bool,
	/// Counts time, output of the system.
	cnt: int,
}

/// Initial predicate.
init {
	is_counting = start_stop,
	cnt = 0,
}

/// Transition relation.
trans {
	// The *next* value of `is_counting` is equal to...
	'is_counting = if 'start_stop {
		// ...if `'start_stop` is true, then the negation of
		// its *previous* value...
		¬is_counting
	} else {
		// ...otherwise, it is equal to its previous value.
		is_counting
	},
	'cnt = if 'reset {
		0
	} else if 'is_counting {
		cnt + 1
	} else {
		cnt
	},
}

/// Candidate invariants, or &quot;Proof Objectives&quot; (`po_s`).
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;reset works&quot;: reset ⇒ cnt = 0,
	&quot;is_counting implies cnt &gt; 0&quot;: (is_counting ⋀ ¬start_stop) ⇒ cnt &gt; 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
running BMC, looking for falsifications for 3 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
found a falsification at depth 1:
- `is_counting implies cnt &gt; 0` = (=&gt; (and is_counting (not start_stop)) (&gt; cnt 0))
  |=| Step 0
  |         cnt = 0
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 1
  |         cnt = 0
  | is_counting = true
  |       reset = true
  |  start_stop = false
  |=|
checking for falsifications at depth 2
checking for falsifications at depth 3
checking for falsifications at depth 4
checking for falsifications at depth 5
checking for falsifications at depth 6
checking for falsifications at depth 7
checking for falsifications at depth 8
checking for falsifications at depth 9
checking for falsifications at depth 10

|===| Bmc result
| - could not find falsifications for the following candidate(s)
|   `cnt is positive`
|   `reset works`
|
| - found a falsification for the following candidate(s)
|   `is_counting implies cnt &gt; 0`
|
| - system is unsafe
|===|
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction"><a class="header" href="#induction">Induction</a></h1>
<p>Let's get a little bit abstract and meta. The incremental BMC approach we have seen in previous
chapters can itself be seen as a transition system. To do this formally, we would need a whole
bunch of notions from logics which are far beyond this book's scope. No matter, we can discuss
BMC as a transition system informally, with words. Writing <em>counterexample</em> constantly is quite
tedious, we will use the much shorter <em>cex</em> (plural <em>cex-s</em>) contraction instead. Also, assume
there is only one candidate for simplicity.</p>
<p><br />
</p>
<p>We can see BMC as having a state: the unrolling depth <code>k</code> from the initial state at which it
currently is. We can say it produces a boolean output that's <code>true</code> if a cex for the candidate
exists at depth <code>k</code>. BMC's starting point is <em>&quot;check the initial states for a cex (of the
candidate)&quot;</em>, which we can rephrase as</p>
<ul>
<li><code>init</code>: unroll the system at depth <code>0</code> from the initial state and check for cex.</li>
</ul>
<p>A BMC <em>transition</em> amounts to unrolling the transition relation one step further (depth <code>k</code>), and
check for falsification at <code>k</code>. Rephrased to echo <code>init</code>'s formulation, we get</p>
<ul>
<li><code>trans(k-1, k)</code>: from an unrolling at <code>k-1</code> from the initial states with no cex, unroll to <code>k</code>
and check for a cex (with <code>k &gt; 0</code>).</li>
</ul>
<p>So now we have a representation of BMC as a transition system with its <code>init</code> predicate and <code>trans</code>
relation.</p>
<p><br />
</p>
<p>It would be interesting to find a candidate invariant for BMC and try to prove it over the
transition system representation of BMC we just introduced. As some readers have probably intuited,
BMC actually has the property that it always finds the shortest cex possible in terms of <em>depth</em>
(number of unrollings). More precisely, it finds one of them: if BMC produces a cex (trace of <code>k</code>
states) of length <code>k</code>, there might be other cex-s of length <code>k</code> (and of length <code>i &gt; k</code>). However,
there cannot exist a shorter cex (of length <code>i &lt; k</code>). More generally:</p>
<ul>
<li><code>candidate(k)</code>: when BMC is unrolled at <code>k</code> from the initial states, then no cex of length <code>0 ≤ i &lt; k</code> exists.</li>
</ul>
<p>To be clear, our goal is to find a way to prove that <code>candidate</code> is an invariant for BMC, which
is represented as a transition system by the <code>init</code> predicate and <code>trans</code> relation above.</p>
<p><br />
</p>
<p>The question now is <em>&quot;How can we prove that BMC verifies <code>candidate</code>?&quot;</em>, or <em>&quot;What would such a
proof look like?&quot;</em>. Back when we discussed transition system, we managed to prove a few properties
regarding the stopwatch system's transition relation. For instance, we previously proved that
assuming <code>cnt_0 &gt; 7</code>, then we cannot have <code>cnt_1 = 0</code> without <code>reset_1</code> being <code>true</code> if state <code>1</code>
is a successor of state <code>0</code>.</p>
<p>So we could start building a proof for <code>candidate</code> by checking if it is a <em>consequence</em> of <code>trans</code>:
is it true that <code>trans(k-1, k) ⇒ candidate(k)</code>?. Let's assume we have an unrolling at depth <code>k-1</code>
from the initial states with no cex; by <code>trans</code>, the next BMC step is to unroll to <code>k</code> and check
for a cex at <code>k</code>. Looking at <code>candidate</code> now, is it the case that no cex of length <code>i &lt; k</code> can
exist?</p>
<p>Well no, looking only at the assumptions we made we cannot draw that conclusion: <code>trans</code> tells us
there is no cex at <code>k-1</code>, but that's it. We know nothing of potential cex-s at <code>i &lt; k - 1</code>. So,
<code>candidate</code> is not a <em>consequence</em> of <code>trans</code>. All hope is not lost: our tiny proofs over the
stopwatch system actually made assumptions about the <em>previous</em> state. &quot;<strong>Assuming</strong> <code>cnt_0 &gt; 7</code>,
then we cannot have <code>cnt_1 = 0</code> without ...&quot;</p>
<p><br />
</p>
<p>Instead of checking if <code>candidate</code> is a <em>consequence</em> of <code>trans</code> (which it is not as we just saw) we
could check <code>trans</code> <em>preserves</em> <code>candidate</code>. Since <code>trans</code> relates succeeding states <code>k-1</code> and <code>k</code>,
we say that <code>trans</code> <em>preserves</em> <code>candidate</code> if <code>candidate(k-1) ∧ trans(k-1, k) ⇒ candidate(k)</code>. That
is, <em>&quot;states verifying <code>candidate</code> cannot, in one application of <code>trans</code>, reach a state falsifying
<code>candidate</code>&quot;</em>.</p>
<p>Is it the case though? We take the same assumptions as above, when we looked at a transition from
<code>k-1</code> to <code>k</code>, and also assume <code>candidate</code> at <code>k-1</code>: <em>&quot;no cex of length <code>i &lt; k-1</code> exists&quot;</em>. By
<code>trans</code>, we unroll to <code>k</code> and check for a cex at <code>k</code>. Can there be cex of length <code>i &lt; k</code>? No:
<code>trans</code> tells us there was no cex at <code>k-1</code>, and our new <code>candidate</code>-assumption in the previous
state tells us no cex of length <code>i &lt; kh-1 </code> exists.</p>
<p><br />
</p>
<p>Sweet, <code>trans</code> preserves <code>candidate</code>: from a state verifying <code>candidate</code>, we can only reach states
that also verify <code>candidate</code>. Hence, a state verifying <code>candidate</code> <em>cannot lead</em> to a state
falsifying it by repeated applications of <code>trans</code>. Is this enough to decide <code>candidate</code> to be an
invariant for BMC? No, unless we show all our initial states verify <code>candidate</code>.</p>
<p>Imagine for instance we got BMC wrong and started at depth <code>1</code> instead of <code>0</code>, with exactly the
same <code>trans</code>. Then, since we never checked for a cex at <code>0</code>, <code>candidate</code> has no reason to be true
at <code>1</code>. More generally, if our initial states do not all verify <code>candidate</code>, then the fact that
<code>trans</code> preserves <code>candidate</code> is not helpful because it says nothing about transitions from a
state that does <strong>not</strong> verify <code>candidate</code>.</p>
<p>Do(es) BMC's initial state(s) verify <code>candidate</code> then? That is, when BMC is unrolled at <code>0</code> from
the initial states, is it possible that a cex of length <code>i</code> with <code>0 ≤ i &lt; 0</code> exists? Well, since
there is no <code>i</code> such that <code>0 ≤ i &lt; 0</code>, then no.</p>
<p><br />
</p>
<p>Putting both results together we have</p>
<ul>
<li>BMC's starting point verifies <code>candidate</code>, <em>i.e.</em> <code>init ⇒ candidate(0)</code>, and</li>
<li>BMC's notion of transition preserves <code>candidate</code>, <em>i.e.</em> <code>candidate(k-1) ∧ trans(k-1, k) ⇒ candidate(k)</code>.</li>
</ul>
<p>Then, by <em>induction</em>, executions of BMC cannot ever falsify <code>candidate</code>.</p>
<h2 id="one-last-short-smt-dive"><a class="header" href="#one-last-short-smt-dive">One Last Short SMT Dive</a></h2>
<p>To sum up, given a transition system <code>𝕋</code> with state variables <code>s</code> and specified by <code>(init(s), trans(s, s'))</code>, we can invoke <em>induction</em> to prove that <code>candidate(s)</code> is an invariant for <code>𝕋</code> if
we have shown both <em>base</em> and <em>step</em>:</p>
<ul>
<li><em>base</em>: for all <code>s</code>, <code>init(s) ⇒ candidate(s)</code>;</li>
<li><em>step</em>: for all <code>s</code> and <code>s'</code>, <code>candidate(s) ∧ trans(s, s') ⇒ candidate(s')</code>.</li>
</ul>
<p>We can rephrase these two in terms of SMT solving and formula (un)satisfiability:</p>
<ul>
<li><em>base</em>: <code>init(s) ∧ ¬candidate(s)</code> is unsatisfiable;</li>
<li><em>step</em>: <code>candidate(s) ∧ trans(s, s') ∧ ¬candidate(s')</code> is unsatisfiable.</li>
</ul>
<p>We all know what this means: it is finally time to achieve our dream of proving that the
stopwatch's counter is always positive. I will use the version that starts from <code>cnt = 0</code>, not the
one where it can take an arbitrary positive value. Both versions work for this proof, but the
former is better for obtaining non-trivial (length <code>0</code>) counterexamples if we need to.</p>
<blockquote>
<p>Readers eager to <em>learn by doing</em> can start from any of the previous SMT examples involving BMC
and try to conduct the proof themselves. The SMT examples for BMC have definitions for both
<code>init</code> and <code>trans</code> ready to use. The easy version consists in having an SMT-LIB script for the
<em>base</em> case, and another one for the <em>step</em> case. Solution in the <a href="induction/index.html#stopwatch-base">Stopwatch
Base</a> and <a href="induction/index.html#stopwatch-step">Stopwatch Step</a> sections.</p>
<p>Bonus points if you can do both with just one script, using activation literals. Perfect score if
you can do both checks using only one activation literal, <strong>solely</strong> for the purpose of
(de)activating <code>init</code>.</p>
<p>Perfect score solution in the <a href="induction/index.html#stopwatch-actlit">Stopwatch Actlit</a> section.</p>
</blockquote>
<p><br />
</p>
<h3 id="base"><a class="header" href="#base">Base</a></h3>
<p>SMT examples for BMC from previous chapters already have definitions for the stopwatch's <code>init</code> and
<code>trans</code>. For convenience and readability, we define a <code>candidate</code> predicate over the system's
counter:</p>
<pre><code class="language-text">(define-fun candidate ((|s.cnt| Int)) Bool
    (&gt;= |s.cnt| 0)
)
</code></pre>
<p>In the <em>base</em> check, we are only concerned with the initial states. All we need to do</p>
<ul>
<li>is declare our state variables,</li>
<li>assert that they are a legal initial state,</li>
<li>assert that they falsify our candidate, and</li>
<li>ask whether this is satisfiable.</li>
</ul>
<pre><code class="language-text">(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)

(assert (init start_stop_0 reset_0 is_counting_0 cnt_0))
(assert (not (candidate cnt_0)))

; Is there a state that's initial but does not verify `candidate`?
(check-sat)
</code></pre>
<p>Z3 easily answers our question.</p>
<blockquote>
<p>Full code in the <a href="induction/index.html#stopwatch-base">Stopwatch Base</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
<p>Done: we proved the <em>base</em> case, <em>step</em> is next, let's move on.</p>
<p><br />
</p>
<h3 id="step"><a class="header" href="#step">Step</a></h3>
<p>For the <em>step</em> check, which we are doing separately (in a different file) from <em>base</em>, we first
need to declare two states since we need to check that <code>trans</code> preserves <code>candidate</code>.</p>
<pre><code class="language-text">; Previous state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; Next state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
</code></pre>
<p>Next, we want to ask whether it is possible to have</p>
<ul>
<li>state <code>0</code> verify <code>candidate</code>,</li>
<li>state <code>1</code> be a successor of state <code>0</code>, and</li>
<li>state <code>0</code> falsify <code>candidate</code>.</li>
</ul>
<pre><code class="language-text">(assert (candidate cnt_0))
(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))
(assert (not (candidate cnt_1)))

; Is there a state verifying `candidate` that can
; reach a state falsifying it in one transition?
(check-sat)
</code></pre>
<p>And that's it. Unless Z3 decides to answer <code>sat</code> for some reason, we are done.</p>
<blockquote>
<p>Full code in the <a href="induction/index.html#stopwatch-step">Stopwatch Step</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; play drumroll.wav
&gt; z3 test.smt2
unsat
</code></pre>
<p>Done and done. Both <em>base</em> and <em>step</em> hold, and thus we can finally invoke induction and conclude
that <code>cnt ≥ 0</code> is an invariant for the stopwatch system.</p>
<p>Before we move on to mikino's induction mode, some readers might want to check out Section
<a href="induction/index.html#stopwatch-actlit">Stopwatch Actlit</a> below. In it, we conduct <em>base</em> and <em>step</em> in succession in a
single file using an activation literal. That's not all we do however, there is a clever trick that
we use for the checks. The trick is discussed in details in the comments.</p>
<p><br />
</p>
<h3 id="full-code-for-all-examples-3"><a class="header" href="#full-code-for-all-examples-3">Full Code For All Examples</a></h3>
<h4 id="stopwatch-base"><a class="header" href="#stopwatch-base">Stopwatch Base</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">; Initial predicate.
(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
    )
)

(define-fun candidate ((|s.cnt| Int)) Bool
    (&gt;= |s.cnt| 0)
)

(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)

(assert (init start_stop_0 reset_0 is_counting_0 cnt_0))
(assert (not (candidate cnt_0)))

; Is there a state that's initial but does not verify `candidate`?
(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<h4 id="stopwatch-step"><a class="header" href="#stopwatch-step">Stopwatch Step</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">; Initial predicate.
(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
    )
)
(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

(define-fun candidate ((|s.cnt| Int)) Bool
    (&gt;= |s.cnt| 0)
)

; Previous state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; Next state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (candidate cnt_0))
(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))
(assert (not (candidate cnt_1)))

; Is there a state verifying `candidate` that can
; reach a state falsifying it in one transition?
(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<h4 id="stopwatch-actlit"><a class="header" href="#stopwatch-actlit">Stopwatch Actlit</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<p>Until now, we performed the <em>step</em> check of an induction proof by giving ourselves a state <code>0</code> and
a state <code>1</code> such that</p>
<ul>
<li><code>trans(s_0, s_1)</code>: state <code>1</code> is state <code>0</code>'s successor,</li>
<li><code>candidate(s_0)</code>: state <code>0</code> verifies the candidate,</li>
<li><code>¬candidate(s_1)</code>: state <code>1</code> falsifies the candidate.</li>
</ul>
<p>Now, the example below swaps the state indices <code>0</code> and <code>1</code>. That is:</p>
<ul>
<li><code>trans(s_1, s_0)</code>: state <code>0</code> is state <code>1</code>'s successor,</li>
<li><code>candidate(s_1)</code>: state <code>1</code> verifies the candidate,</li>
<li><code>¬candidate(s_0)</code>: state <code>0</code> falsifies the candidate.</li>
</ul>
<p>This does not really change anything by itself, the check is same except that the indices have
changed. We do need to be careful to extract the counterexample correctly though.</p>
<p>The reason we present this version is that this <em>reverse-unrolling</em> version lets us keep state <code>0</code>
as the <em>last state of the trace</em>, <em>i.e.</em> the state on which the falsification occurs. In normal
unrolling, if we wanted to unroll the transition relation more, we would need to introduce <code>s_2</code>,
deactivate <code>¬candidate(s_1)</code>, assert <code>candidate(s_1)</code>, and conditionally assert <code>¬candidate(s_2)</code>.</p>
<p>With reverse-unrolling we can just say <code>s_2</code> is <code>s_1</code>'s previous state, and assert
<code>candidate(s_2)</code>. We are not unrolling more than once here (a process called <code>k</code>-induction), but
this reverse-unrolling trick is still convenient <em>w.r.t.</em> the <em>base</em> check. The <em>base</em> check asserts
<code>¬candidate(s_0)</code>, which <em>step</em> also needs.</p>
<pre><code class="language-text">; Initial predicate.
(define-fun init
    (
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
    )
    Bool

    (and
        (= |s.is_counting| |s.start_stop|)
        (=&gt; |s.reset| (= |s.cnt| 0))
        (&gt;= |s.cnt| 0)
    )
)
(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

(define-fun candidate ((|s.cnt| Int)) Bool
    (&gt;= |s.cnt| 0)
)


(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)

; Wait, shouldn't this be under an activation literal?
(assert (not (candidate cnt_0)))
; No because we're being very clever. More on that in the
; step check below.

(echo &quot;base check, expecting `unsat`&quot;)
(declare-const base_actlit Bool)
(assert (=&gt; base_actlit
    (init start_stop_0 reset_0 is_counting_0 cnt_0)
))
(check-sat-assuming (base_actlit))


(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(echo &quot;step check, expecting `unsat`&quot;)
(assert
    (trans
        ; State `1` is first?
        start_stop_1 reset_1 is_counting_1 cnt_1
        ; State `0` is its successor?
        start_stop_0 reset_0 is_counting_0 cnt_0
    )
)
(assert (candidate cnt_1))
; Most unhorthodox. We are reverse-unrolling™.
; When we checked for base above, we asserted `(not (candidate cnt_0))`
; **unconditionnaly**. So at this point, we have
; - candidate(s_1)
; - trans(s_1, s_0)
; - ¬candidate(s_0)
;
; By unrolling backwards, with `s_0` the *last* state, we can reverse-unroll
; without changing anything, just adding a state `s_2` and asserting
; `trans(s_2, s_1)`.
;
; This is useful when doing &quot;k-induction&quot;, which requires unrolling more than
; once in step (and base), and because SMT-solvers work by **learning** facts
; about the SMT instance they work on. These facts are *kept between checks*.
; So, Z3 will learn facts from the three assertions above in the `check-sat`
; below. If we reverse-unroll once more by adding an `s_2` as the predecessor
; of `s_1`, then Z3 will be able to re-use facts it learnt since we only added
; to the instance, but did not change anything that was there.

(check-sat)

(echo &quot;induction proof complete&quot;)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
base check, expecting `unsat`
unsat
step check, expecting `unsat`
unsat
induction proof complete
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction-mikino-and-step-cex-s"><a class="header" href="#induction-mikino-and-step-cex-s">Induction: Mikino and Step Cex-s</a></h1>
<p>BMC is not the only thing mikino can do. It also has an induction mode which is activated with the
<code>check</code> sub-command.</p>
<blockquote>
<p><strong>Pro tip:</strong> remember the <code>--smt_log &lt;DIR&gt;</code> flag from mikino's <code>bmc</code> mode? It specifies a
directory where mikino will create one SMT-LIB 2 file per solver it uses, and log all the commands
issued to that solver. Mikino's <code>check</code> mode has it too:</p>
<pre><code class="language-text">&gt; mikino check --smt_log smt_traces test.mkn
&gt; tree smt_traces/
smt_traces
├── base.smt2
└── step.smt2
</code></pre>
<p>This can be useful to inspect the exact checks mikino is performing and modify/relaunch them.</p>
</blockquote>
<p>Let's make sure mikino is able to prove that <code>cnt ≥ 0</code> on the stopwatch system. I am using the
version of the system that starts at <code>0</code></p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Initial predicate.
init {
	is_counting = start_stop,
	cnt = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>with a <code>cnt ≥ 0</code> candidate as well as a few falsifiable other candidates:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Candidate invariants, or &quot;Proof Objectives&quot; (`po_s`).
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<p><br />
</p>
<p>Let's run mikino in <code>check</code> mode on this system, full code in the <a href="mikino_induction/index.html#full-code">Full Code</a> section.</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step k
  |         cnt = 2
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step k + 1
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=|
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step k
  |         cnt = 4
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step k + 1
  |         cnt = 5
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `cnt is positive`
|===|
</code></pre>
<p>Looking just at the final result, mikino is telling us that all candidates hold in the initial
state(s). So, the <em>base</em> part of the induction proof holds for all candidates. Next, mikino reports
that two of the candidates are not preserved by the transition relation. Since the <em>check</em> part of
the induction proof does not hold for these candidates, mikino does not know whether they hold and
tells us that the system <strong>might</strong> be unsafe. Based on the checks mikino performed, it cannot
decide whether they are invariants or not.</p>
<p>Last, mikino reports that <code>cnt is positive</code> is actually preserved by the transition relation
meaning <em>step</em>, in addition to <em>base</em>, holds for this candidate. Mikino can thus conclude that it
is an invariant for the system.</p>
<p><br />
</p>
<p>If we take a closer look at mikino's output during the <em>step</em> checks, we see that mikino is doing
more that just saying some <em>step</em> checks failed. When they do, mikino also outputs a <em>step
counterexample (cex)</em>. Remember what a <em>step</em> check is: for any state <code>k</code></p>
<ul>
<li>assuming state <code>k</code> verifies <code>candidate</code>,</li>
<li>assuming state <code>k+1</code> is a successor of state <code>k</code>,</li>
<li>is it possible that state <code>k+1</code> falsifies <code>candidate</code>?</li>
</ul>
<p>If it is possible, it means that there exists a state <code>k</code> verifying <code>candidate</code> which has a
successor state <code>k+1</code> falsifying <code>candidate</code>. Under the hood, this means the solver answered <code>sat</code>
to mikino's <em>step</em> <code>check-sat</code> query, meaning mikino can invoke <code>get-model</code> for <em>step cex</em>: a pair
of succeeding states showing that <code>candidate</code> is not necessarily preserved by the transition
relation.</p>
<p>For candidate <code>cnt ≥ 2</code> for instance, mikino lets us know that from a state where <code>cnt = 2</code> which
verifies the candidate, it is possible in one transition to reach a state where <code>cnt = 3</code> which
falsifies the candidate. Mikino gives us the values of all state variables so that we know how
precisely the <em>bad</em> state can be reached. There might be more than one step cex, as is the case for
candidate <code>cnt ≥ 2</code>: mikino (the SMT solver, really) decides to start counting in step <code>k+1</code> in the
step cex, but we could get the same result if we were already counting in step <code>k</code>.</p>
<p><br />
</p>
<p>This notion of step cex is important because, on real systems, candidates tend not to be inductive.
We will discuss this in the next chapter, but a candidate can be an invariant without being
inductive. There are various ways we can go about proving that a non-inductive candidate is an
invariant, but most of them (including the one we will discuss soon) involve manually or
automatically looking at step cex-s to understand why the candidate is not inductive and <em>&quot;act&quot;</em>
accordingly. (The meaning of <em>&quot;act&quot;</em> depends on the actual technique used to get around
non-inductiveness.)</p>
<p><br />
</p>
<h2 id="run-bmc-again"><a class="header" href="#run-bmc-again">Run BMC, Again</a></h2>
<p>We can change the mikino command we used to instruct mikino to run BMC on the candidates it failed
to prove. For instance, <code>mikino check --bmc test.mkn</code> will run BMC after the proof attempts in an
attempt to falsify remaining candidates. More precisely, this command will run BMC without a
maximum unrolling depth.</p>
<p>On this simple example, we already know the remaining candidates are falsifiable in a small number
of transitions. When we do not have this information, it can be a good idea to specify a maximum
unrolling depth with <code>--bmc_max &lt;int&gt;</code> just like we did in <code>bmc</code> mode. Note that using the
<code>--bmc_max</code> flag automatically activates BMC, so we don't need the <code>--bmc</code> flag anymore.</p>
<p>On our example</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Candidate invariants, or &quot;Proof Objectives&quot; (`po_s`).
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<p>the last two candidates should be falsifiable at depth <code>3</code> and <code>5</code> respectively. Let's make sure
this is the case.</p>
<pre><code class="language-text">&gt; mikino check --bmc_max 5 test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step k
  |         cnt = 2
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step k + 1
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=|
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step k
  |         cnt = 4
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step k + 1
  |         cnt = 5
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `cnt is positive`
|===|

running BMC, looking for falsifications for 2 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
checking for falsifications at depth 2
checking for falsifications at depth 3
found a falsification at depth 3:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step 0
  |         cnt = 0
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 1
  |         cnt = 1
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 2
  |         cnt = 2
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 3
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|
checking for falsifications at depth 4
checking for falsifications at depth 5
found a falsification at depth 5:
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step 0
  |         cnt = 0
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=| Step 1
  |         cnt = 1
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 2
  |         cnt = 2
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 3
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 4
  |         cnt = 4
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step 5
  |         cnt = 5
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|

|===| Bmc result
| - found a falsification for the following candidate(s)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system is unsafe
|===|
</code></pre>
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// State variables.
svars {
	/// Inputs of the system.
	start_stop reset: bool,
	/// Keeps track of whether we are counting.
	is_counting: bool,
	/// Counts time, output of the system.
	cnt: int,
}

/// Initial predicate.
init {
	is_counting = start_stop,
	cnt = 0,
}

/// Transition relation.
trans {
	// The *next* value of `is_counting` is equal to...
	'is_counting = if 'start_stop {
		// ...if `'start_stop` is true, then the negation of
		// its *previous* value...
		¬is_counting
	} else {
		// ...otherwise, it is equal to its previous value.
		is_counting
	},
	'cnt = if 'reset {
		0
	} else if 'is_counting {
		cnt + 1
	} else {
		cnt
	},
}

/// Candidate invariants, or &quot;Proof Objectives&quot; (`po_s`).
candidates {
	&quot;cnt is positive&quot;: cnt ≥ 0,
	&quot;cnt ≤ 2&quot;: cnt ≤ 2,
	&quot;cnt ≤ 4&quot;: cnt ≤ 4,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino bmc --bmc_max 10 test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `cnt ≤ 2` = (&lt;= cnt 2)
  |=| Step k
  |         cnt = 2
  | is_counting = false
  |       reset = false
  |  start_stop = false
  |=| Step k + 1
  |         cnt = 3
  | is_counting = true
  |       reset = false
  |  start_stop = true
  |=|
- `cnt ≤ 4` = (&lt;= cnt 4)
  |=| Step k
  |         cnt = 4
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=| Step k + 1
  |         cnt = 5
  | is_counting = true
  |       reset = false
  |  start_stop = false
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `cnt ≤ 2`
|   `cnt ≤ 4`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `cnt is positive`
|===|
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candidate-strengthening"><a class="header" href="#candidate-strengthening">Candidate Strengthening</a></h1>
<blockquote>
<p>Candidate strengthening is about making non-inductive candidates inductive (when possible). It is
somewhat difficult to come up with an example that is</p>
<ul>
<li>interesting for strengthening,</li>
<li>not too artificial, <em>i.e.</em> is relatively realistic for a developer, and</li>
<li>is accessible without too much explanation.</li>
</ul>
<p>While not extremely complex, the central example of this chapter and the manipulations in general
are going to be more involved than what we have discussed so far.</p>
<p>This chapter also touches on the very high complexity and potential undecidability of
verification.</p>
<p>This chapter is quite technical, and a bit theoretical. It is recommended that you understand all
the concepts introduced so far before diving into this chapter. Some understanding of Rust could
help in places, although it is by no means mandatory.</p>
</blockquote>
<p><br />
</p>
<p>We have seen two kinds of candidate up to this point:</p>
<ul>
<li>inductive candidates, meaning induction can prove they are invariants, and</li>
<li>falsifiable candidates, which can be falsified by running BMC for long enough.</li>
</ul>
<p>Not all invariants are inductive. Meaning it is possible to get a <em>step</em> counterexample, <em>i.e.</em> the
transition relation does not preserve the candidate, even though the candidate is an invariant and
no legal trace of states can falsify it.</p>
<p><br />
</p>
<h2 id="array-value-grouping"><a class="header" href="#array-value-grouping">Array Value Grouping</a></h2>
<p>Let's switch gears and look at an actual piece of (Rust) code. Assume we have an array <code>arr</code> of
statically-known size <code>len</code> of elements of type <code>T</code> (<code>arr</code> has type <code>[T; len]</code>. Say we also have an
integer (<code>usize</code>) value <code>grouping</code>. What we want to do is <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" title="The fold function on wikipedia">fold</a> over successive groups
(sub-arrays) of length <code>grouping</code> of the elements of <code>arr</code>.</p>
<p>In practice, we want to have a type <code>Wrap</code> that stores <code>arr</code> and <code>grouping</code>, and exposes a <code>fold</code>
function over values of type <code>&amp;[T]</code> which is <strong>guaranteed</strong> to store exactly <code>grouping</code> elements.
Fold implements an sliding, non-overlapping window of length <code>grouping</code> over <code>arr</code>. Here is what
using it would look like.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">fn main() {
    // `len` ~~~~~~v
    let arr: [f64; 6] = [0., 1., 2., 3., 4., 5.];
    // `grouping` ~~~~~~~~~~~~v
    let wrap = Wrap::new(arr, 3);
    let value_1 = wrap.fold(0., |acc, arr| {
        println!(
            &quot;len: {} | arr[0]: {}, arr[1]: {}, arr[2]: {}&quot;,
            arr.len(),
            arr[0],
            arr[1],
            arr[2]
        );
        assert_eq!(arr.len(), 3);
        let new_acc = acc + arr[0] * arr[1] * arr[2];
        println!(&quot;acc: {}, new_acc: {}&quot;, acc, new_acc);
        new_acc
    });
    println!(&quot;fold result: {}&quot;, value_1);

    println!(&quot;\n---------------------\n&quot;);

    // `len` ~~~~~~v
    let arr: [f64; 6] = [0., 1., 2., 3., 4., 5.];
    // `grouping` ~~~~~~~~~~~~v
    let wrap = Wrap::new(arr, 2);
    let value_2 = wrap.fold(0., |acc, arr| {
        println!(
            &quot;len: {} | arr[0]: {}, arr[1]: {}&quot;,
            arr.len(),
            arr[0],
            arr[1]
        );
        assert_eq!(arr.len(), 2);
        let new_acc = acc + arr[0] * arr[1];
        println!(&quot;acc: {}, new_acc: {}&quot;, acc, new_acc);
        new_acc
    });
    println!(&quot;fold result: {}&quot;, value_2);
}
</code></pre></pre>
<p>Which produces</p>
<pre><code class="language-text">len: 3 | arr[0]: 0, arr[1]: 1, arr[2]: 2
acc: 0, new_acc: 0
len: 3 | arr[0]: 3, arr[1]: 4, arr[2]: 5
acc: 0, new_acc: 60
fold result: 60

---------------------

len: 2 | arr[0]: 0, arr[1]: 1
acc: 0, new_acc: 0
len: 2 | arr[0]: 2, arr[1]: 3
acc: 0, new_acc: 6
len: 2 | arr[0]: 4, arr[1]: 5
acc: 6, new_acc: 26
fold result: 26
</code></pre>
<p><br />
</p>
<p>Full code available below. For now let's turn to how the <code>fold</code> function would be implemented. Say
<code>init</code> and <code>next</code> are <code>fold</code>'s two arguments (initial value and fold function respectively). Then
the body of <code>fold</code> could look something like</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut acc = init;
        let mut i = 0;
        while i &lt; len {
            let next_i = i + grouping;
            acc = next(acc, &amp;arr[i..next_i]);
            i = next_i
        }
        acc
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>local variable <code>acc</code> is initially <code>init</code>, and the loop updates its value with the result of the
call to <code>next</code>;</li>
<li>the <code>while</code> loop increments an <code>i</code> index until it goes over <code>len</code> (length of <code>arr</code>);</li>
<li>at the end of each iteration, the new value of <code>i</code> is <code>i + grouping</code>;</li>
<li>the call to <code>next</code> gives it the current value of the accumulator, and a slice from <code>i</code> to <code>i + grouping</code> ---remember that <code>n..m</code> is the interval <code>[n, m[</code>: <code>m</code> is not included in the interval;</li>
<li>when we exit the loop, we return the final value of <code>acc</code>.</li>
</ul>
<details>
	<summary>Full code for this example, requires some Rust knowledge.</summary>
<pre><pre class="playground"><code class="language-rust">#![allow(non_upper_case_globals)]

pub struct Wrap&lt;T, const len: usize&gt; {
    arr: [T; len],
    grouping: usize,
}
impl&lt;T, const len: usize&gt; Wrap&lt;T, len&gt; {
    /// Constructor.
    pub fn new(arr: [T; len], grouping: usize) -&gt; Self {
        if len % grouping != 0 {
            panic!(
                &quot;grouping value {} is not a multiple of array length ({})&quot;,
                grouping, len,
            );
        }
        if grouping &lt; 1 {
            panic!(&quot;illegal grouping value {}, must be &gt; 0&quot;, grouping)
        }
        Self { arr, grouping }
    }
    /// Grouped fold.
    pub fn fold&lt;Acc&gt;(&amp;self, init: Acc, mut next: impl FnMut(Acc, &amp;[T]) -&gt; Acc) -&gt; Acc {
        let (arr, grouping) = (&amp;self.arr, self.grouping);
        let mut acc = init;
        let mut i = 0;
        while i &lt; len {
            let next_i = i + grouping;
            acc = next(acc, &amp;arr[i..next_i]);
            i = next_i
        }
        acc
    }
}

fn main() {
    // `len` ~~~~~~v
    let arr: [f64; 6] = [0., 1., 2., 3., 4., 5.];
    // `grouping` ~~~~~~~~~~~~v
    let wrap = Wrap::new(arr, 3);
    let value_1 = wrap.fold(0., |acc, arr| {
        println!(
            &quot;len: {} | arr[0]: {}, arr[1]: {}, arr[2]: {}&quot;,
            arr.len(),
            arr[0],
            arr[1],
            arr[2]
        );
        assert_eq!(arr.len(), 3);
        let new_acc = acc + arr[0] * arr[1] * arr[2];
        println!(&quot;acc: {}, new_acc: {}&quot;, acc, new_acc);
        new_acc
    });
    println!(&quot;fold result: {}&quot;, value_1);

    println!(&quot;\n---------------------\n&quot;);

    // `len` ~~~~~~v
    let arr: [f64; 6] = [0., 1., 2., 3., 4., 5.];
    // `grouping` ~~~~~~~~~~~~v
    let wrap = Wrap::new(arr, 2);
    let value_2 = wrap.fold(0., |acc, arr| {
        println!(
            &quot;len: {} | arr[0]: {}, arr[1]: {}&quot;,
            arr.len(),
            arr[0],
            arr[1]
        );
        assert_eq!(arr.len(), 2);
        let new_acc = acc + arr[0] * arr[1];
        println!(&quot;acc: {}, new_acc: {}&quot;, acc, new_acc);
        new_acc
    });
    println!(&quot;fold result: {}&quot;, value_2);
}
</code></pre></pre>
</details>
<p><br />
</p>
<p>Now let's think about this a little bit. The value <code>&amp;arr[i..next_i]</code>, where <code>next_i</code> is <code>i + grouping</code>, does not always <em>make sense</em>: <code>i + grouping</code> might strictly superior to <code>len</code> (<code>arr</code>'s
length). This cannot happen if <code>len</code> is a multiple of <code>grouping</code> however, and actually <code>Wrap</code>'s
constructor checks for this.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Constructor.
    pub fn new(arr: [T; len], grouping: usize) -&gt; Self {
        if len % grouping != 0 {
            panic!(
                &quot;grouping value {} is not a multiple of array length ({})&quot;,
                grouping, len,
            );
        }
        if grouping &lt; 1 {
            panic!(&quot;illegal grouping value {}, must be &gt; 0&quot;, grouping)
        }
<span class="boring">}
</span></code></pre></pre>
<p>There is also a check that <code>grouping &gt; 0</code>, otherwise <code>fold</code> would not terminate when <code>len &gt; 0</code>. So
everything should be fine, right? Humans do not make very good proof engines, let's just prove it
to make sure.</p>
<p><br />
</p>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<blockquote>
<p>You are encouraged to think about how you would encode this verification problem so that mikino
can handle it. You will probably not going to succeed unless you are already very familiar with
this kind of encoding. May read a paragraph below or two, think about it some more, read some
more, <em>etc.</em></p>
</blockquote>
<p>Mikino does not accept Rust code, we need to encode what we want to check. Writing an encoder for
(a subset of) of programming language is a very challenging task. It requires an exact
understanding of the semantics of the language and the ability to design encoding rules that
<em>are guaranteed</em> to preserve it, or at least preserve the part relevant for the analysis.
So let's not do that and encode it by hand.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut acc = init;
        let mut i = 0;
        while i &lt; len {
            let next_i = i + grouping;
            acc = next(acc, &amp;arr[i..next_i]);
            i = next_i
        }
        acc
<span class="boring">}
</span></code></pre></pre>
<p>What do we want to check, <em>i.e.</em> what does it mean for this code to <em>make sense</em>? It's really a
matter of how <code>i</code> is related to <code>len</code>. Each iteration <em>makes sense</em> if the interval we use on <code>arr</code>
is legal, meaning <code>i &lt; len</code> and <code>next_i = i + grouping ≤ len</code> (interval is exclusive on its upper
bound). We actually don't care about what's in <code>arr</code>, just that its length is <code>len</code>. Our encoding
can safely ignore <code>arr</code> completely. Same for <code>acc</code>, its value is not relevant for <code>fold</code> to make
sense in how it accesses <code>arr</code>. The only real state variable of interest in this loop is thus <code>i</code>.</p>
<blockquote>
<p>There a whole bunch of additional properties we might want to prove. For instance, that <code>arr</code>
slices do not overlap. The point is that, whatever we are interested in proving, we should remove
everything that is not necessary as we encode the program. However, the encoding should at least
be <em>sound</em>: proving an invariant in the encoding must entail it is an invariant for the original
program.</p>
<p>Here, we are doing the encoding by hand and we can pick and choose what is encoded or left out.
In an actual verification tool, the encoding process would be automatic. Such an automatic
encoder might encode the whole semantics of the program (meaning dealing with arrays at SMT-level
here) and hope for the best, or be clever enough to realize it can excise array-related things
for this particular verification challenge. Writing a clever, automatic encoder is difficult and
challenging, and can void all results if it is not <em>sound</em>.</p>
</blockquote>
<p><br />
</p>
<p>Note that we have a few constants here: <code>len</code> and <code>grouping</code> do not change as the loop runs.
Unfortunately mikino does not have a notion of constant <strong>yet</strong> (contributions are welcome), so we
have to encode them as state variables along with <code>i</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>The surprise state variable <code>done</code> is a flag we are going to use to indicate whether the loop is
done or not. This allows our system to never end, which is a useful property for technical reasons
beyond the scope of this chapter.</p>
<p>We initialize the transition system encoding <code>fold</code>'s loop, as follows.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>init {
    len ≥ 0,
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>The first two simply constrain the values for <code>len</code> (<code>usize</code>, thus <code>≥ 0</code>) and <code>grouping</code> (checked
to be <code>≥ 1</code> by the constructor). Then <code>i</code> is constrained to be equal to its initial value, <code>0</code>. The
<code>done</code> flag is initially true if and only if <code>i ≥ len</code>, which basically means <code>len</code> is <code>0</code> ---<code>arr</code>
is empty, the loop never starts.</p>
<p>Last, we have the assumption we need for the whole thing to work: <code>len</code> is a multiple of
<code>grouping</code>, which <code>Wrap</code>'s constructor checks.</p>
<p><br />
</p>
<p>The transition relation needs to do a few things. Our constants (encoded as state variables) need
to keep their value, since if we left them unconstrained they could take any value. We also need to
update the value of <code>done</code>, and finally that of <code>i</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}
<span class="boring">}
</span></code></pre></pre>
<p><br />
</p>
<h2 id="testing-the-encoding"><a class="header" href="#testing-the-encoding">Testing the Encoding</a></h2>
<p>Before we do anything else, let's think of what happens if <code>len = 8</code> and <code>grouping = 4</code>. Initially
<code>i = 0</code>, then it should increase to <code>i = 4</code>, then to <code>i = 8</code> at which point <code>done = i ≥ len</code>
becomes <code>true</code> and the system stutters (its state variables stay the same forever).</p>
<p>We should make sure our encoding behaves like this. So, what we should ask mikino is <em>&quot;with <code>len = 8</code> and <code>grouping = 4</code>, is it possible to reach a state such that <code>i = len</code>?&quot;</em>. We can do this with
BMC: since we want to reach <code>len = 8 ∧ grouping = 4 ∧ i = len</code>, we can just need ask BMC to try to
falsify <code>¬(len = 8 ∧ grouping = 4 ∧ i = len)</code>.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;candidate&quot;: ¬(len = 8 ⋀ grouping = 4 ⋀ i = len),
}
<span class="boring">}
</span></code></pre></pre>
<p>Mikino yields</p>
<pre><code class="language-text">&gt; mikino bmc test.mkn
running BMC, looking for falsifications for 1 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
checking for falsifications at depth 2
found a falsification at depth 2:
- `candidate` = (not (and (= len 8) (= grouping 4) (= i len)))
  |=| Step 0
  |     done = false
  | grouping = 4
  |        i = 0
  |      len = 8
  |=| Step 1
  |     done = false
  | grouping = 4
  |        i = 4
  |      len = 8
  |=| Step 2
  |     done = true
  | grouping = 4
  |        i = 8
  |      len = 8
  |=| Z3 produced the following unexpected values
  | div0 ((x!0 int) (x!1 int)) int = 2
  | mod0 ((x!0 int) (x!1 int)) int = 0
  |=|

|===| Bmc result
| - found a falsification for the following candidate(s)
|   `candidate`
|
| - system is unsafe
|===|
</code></pre>
<p>We got exactly what we expected, that's encouraging. Also, remember that <a href="strength/../induction" title="Induction chapter">we proved that BMC
produces counterexamples of minimal length</a>. Hence, no shorter trace of states can lead
the system to falsify our property.</p>
<p>Full code available in the <a href="strength/index.html#version-1">Version 1</a> section. You are encouraged to mess around with
the example to get a better understanding of the encoding.</p>
<blockquote>
<p>Mikino reports that Z3 produced unexpected values. This is not relevant for our discussion, but
these <em>functions</em> are part of the model. Z3 is letting us know how it decided to handle division
(modulo) by <code>0</code>. I won't go into deeper details here for space constraints, but this is a
consequence of the fact that our system uses <em>non-linear arithmetic</em>, and non-linear division in
particular. A (system made of) formula(s) <em>uses non-linear arithmetic</em> if it uses
multiplication/division involving more than one variable (<code>x * y</code>, <code>x / y</code>). As opposed to
<em>linear arithmetic</em> which only allows one variable to be used (<code>3 * x</code>, <code>x / 7</code>, <code>0 / x</code>).</p>
<p>SMT is <em>not decidable</em> when non-linear arithmetic is involved, but we will have more to say on
that shortly as we will run into this exact problem.</p>
</blockquote>
<p><br />
</p>
<h2 id="diving-head-first"><a class="header" href="#diving-head-first">Diving Head First</a></h2>
<p>We start with trying to prove that the lower bound of the interval <code>i..(i + grouping)</code> used on
<code>arr</code> is legal, meaning to prove that <code>i &lt; len</code>. More precisely, <code>¬done ⇒ i &lt; len</code> since on exit
(when <code>done</code> is <code>true</code>) we actually should have <code>i = len</code>; let's prove <code>done ⇒ i = len</code> as well.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,
}
<span class="boring">}
</span></code></pre></pre>
<p>Full code in the <a href="strength/index.html#version-2">Version 2</a> section. Running mikino in <code>check</code> mode, we get:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `done then i = len` = (=&gt; done (= i len))
  |=| Step k
  |     done = false
  | grouping = 2
  |        i = (- 1)
  |      len = 0
  |=| Step k + 1
  |     done = true
  | grouping = 2
  |        i = 1
  |      len = 0
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `done then i = len`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `not done then i &lt; len`
|===|
</code></pre>
<p>Well, the good news is that the lower bound of our interval is always legal: mikino proved it. We
get a counterexample (cex) for the second candidate though. A stupid cex too, as <code>i</code> is <em>obviously</em>
positive. At least, it is obviously positive if you take into account the initial states (<code>i</code> = 0),
which the <em>step</em> check of the induction proof does not do by definition. As far as the transition
relation is concerned, there is no reason for <code>i</code> to be positive at some step <code>k</code>.</p>
<p><br />
</p>
<p>Your first reflex might be to add this constraint to the transition relation (<code>(pre i) ≥ 0</code>), which
is a terrible idea. That's the encoding of the original code, you should not touch it as this would
actively mask cex-s. Spurious cex-s in this case, but if you make any mistake when augmenting
<code>trans</code> then you might block actual cex-s and safety proofs you might get would not say anything
about the original system.</p>
<p>The reason why, in this case, it <strong>would</strong> be safe to add <code>(pre i) ≥ 0</code> (don't do it though) is
that it is an invariant, <em>i.e.</em> a <em>consequence</em> of the system's behavior. So there's no reason to
force it on <code>trans</code>, we can just ask mikino to prove it instead.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,
}
<span class="boring">}
</span></code></pre></pre>
<p>Full code in the <a href="strength/index.html#version-2">Version 3</a> section. Mikino tells us</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `done then i = len` = (=&gt; done (= i len))
  |=| Step k
  |     done = false
  | grouping = 2
  |        i = 0
  |      len = 1
  |=| Step k + 1
  |     done = true
  | grouping = 2
  |        i = 2
  |      len = 1
  |=|
- `i ≥ 0` = (&gt;= i 0)
  |=| Step k
  |     done = false
  | grouping = (- 1)
  |        i = 0
  |      len = 1
  |=| Step k + 1
  |     done = false
  | grouping = (- 1)
  |        i = (- 1)
  |      len = 1
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `done then i = len`
|   `i ≥ 0`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `not done then i &lt; len`
|===|
</code></pre>
<p><br />
</p>
<p>Okay, now <code>grouping</code> is negative. There is a pattern emerging: mikino (<em>induction</em>, really) is
stupid and needs to be told everything.</p>
<p><br />
</p>
<h2 id="strengthening-"><a class="header" href="#strengthening-">Strengthening 💪</a></h2>
<p>When we add <code>i ≥ 0</code> as a candidate, we are <em>strengthening</em> candidate <code>done ⇒ i = len</code>. That is,
this candidate is <em>not</em> inductive on the <em>raw system</em> (made of <code>init</code> and <code>trans</code>). If we hope to
prove it by induction, we have to try to prove a <em>stronger</em> version <code>(done ⇒ i = len) ∧ lemma</code>, for
example with <code>lemma ≝ i ≥ 0</code> in the previous example. We added the lemma as a separate candidate,
but morally <code>lemma</code> was not really what we wanted to prove, it was just a <em>lemma</em> we added to help
prove the main candidate (which failed). It did not work, but if we can find a <code>lemma</code> for which
the proof goes through, then we won since the fact that <code>(done ⇒ i = len) ∧ lemma</code> is an invariant
implies that <code>done ⇒ i = len</code> is an invariant.</p>
<blockquote>
<p>We are about to strengthen this candidate manually, but maybe you can see why many
induction-based proof engine have some form of <em>invariant discovery</em>. Such techniques aim at
discovering potentially complex lemmas about the system that strengthen the candidates when
they are not inductive.</p>
</blockquote>
<p><br />
</p>
<p>We could keep on asking mikino for <em>step</em> cex-s and come up with a candidate that will hopefully
block them. But we have been doing this whole thing wrong.</p>
<p>The first thing we should do is write everything we expect to be an invariant. For instance we know
that <code>len ≥ 0</code>, and that <code>grouping ≥ 1</code> and <code>len % grouping = 0</code> (both checked in the constructor).
Our first move should have been to write these candidates down (in addition to <code>i ≥ 0</code>) and make
sure they are actually (inductive) invariants. Besides hopefully strengthening our original
candidates (<code>done ⇒ i = len</code> and <code>¬done ⇒ i &lt; len</code>), we must check that they are invariants since
if they are not something is very wrong ---the system, our encoding, our overall understanding, or
all of the above.</p>
<p>Note that, if the encoding process was automatic, these candidates could have been generated
automatically: <code>len: usize</code> implies <code>len ≥ 0</code>, same for <code>i</code>, and the checks in the constructor
guarantee <code>grouping ≥ 1</code> and <code>len % grouping = 0</code> since neither <code>len</code> nor <code>grouping</code> ever change.
As we will see, this is not enough, and we will need to add another (candidate) invariant that is
less trivial to strengthen our real candidate successfully.</p>
<p><br />
</p>
<p>For now let's just add these new candidates</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	// new
	&quot;len ≥ 0&quot;: len ≥ 0,
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>and run mikino. Full code in the <a href="strength/index.html#version-4">Version 4</a> section.</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `done then i = len` = (=&gt; done (= i len))
  |=| Step k
  |     done = false
  | grouping = 2
  |        i = 3
  |      len = 4
  |=| Step k + 1
  |     done = true
  | grouping = 2
  |        i = 5
  |      len = 4
  |=| Z3 produced the following unexpected values
  | div0 ((x!0 int) (x!1 int)) int = 2
  | mod0 ((x!0 int) (x!1 int)) int = 0
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `done then i = len`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `grouping &gt; 0`
|   `i ≥ 0`
|   `len grouping related`
|   `len ≥ 0`
|   `not done then i &lt; len`
|===|
</code></pre>
<p>At least the new candidates are actual (inductive) invariants. It was not enough to strengthen our
real candidate, but the cex we got is interesting. With <code>len = 4</code> and <code>grouping = 2</code>, the step
check is able to go from <code>i = 3</code> to <code>i = 5</code> and falsify the main candidate.</p>
<p>The problem here, as you might have guessed, is currently <code>i</code> can really take any value as long as
its positive: no (candidate) invariant constrain it besides <code>i ≥ 0</code>. Looking at the code for the
loop again</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut acc = init;
        let mut i = 0;
        while i &lt; len {
            let next_i = i + grouping;
            acc = next(acc, &amp;arr[i..next_i]);
            i = next_i
        }
        acc
<span class="boring">}
</span></code></pre></pre>
<p>we see that <code>i</code> can only be a multiple of <code>grouping</code>. But we cannot know until we try to prove it.
Also, will it strengthen our main candidate enough to make it inductive?</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len ≥ 0&quot;: len ≥ 0,
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
	// new
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>We run mikino but, inconspicuously, we change the command used to run Z3 slightly (change <code>z3</code> in
the string to whatever the path to your Z3 binary is). Full code in the <a href="strength/index.html#version-5">Version 5</a>
section.</p>
<pre><code class="language-bash">&gt; mikino --z3_cmd &quot;z3 -T:5&quot; check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
|===| Error
| smt-level error:
| - smt solver reported `timeout`
| - during step check
|===|
</code></pre>
<p>Adding <code>-T:5</code> to the Z3 command tells Z3 to timeout after five seconds. Feel free to increase the
timeout, unless you are from the future and using a version Z3 that performs better on non-linear
arithmetic, the <em>step</em> check will never end. Because of...</p>
<p><br />
</p>
<h2 id="undecidability"><a class="header" href="#undecidability">Undecidability</a></h2>
<p>This small aside illustrates the importance of delimiting precisely the <em>logical fragment</em> in which
your encoding takes place. That is, what the formulas mention: strings, arrays, non-linear
arithmetic?</p>
<p>Verification is expensive; very expensive. SMT checks themselves are at least exp-time, meaning
that if <code>n</code> is <em>&quot;the size of the problem&quot;</em>, the complexity of SMT checks is at least <code>2ⁿ</code>. Most
SMT-based verification techniques end up being at least <code>k</code>-exp-time, also informally called <em>tower
of exponential</em>, which is even worse than it sounds:</p>
<pre><code class="language-text">2^(2^(2^(2^(.....2ⁿ))))
^^^^^^^^^^^^^^^^^^
    `k` times
</code></pre>
<p>where <code>k</code> is some arbitrarily large constant specific to a given problem.</p>
<p>So that's not great. As it turns out, the hardware is now so efficient and the tools so carefully
implemented and optimized that despite being <code>k</code>-exp-time, we can actually verify very interesting
and complex systems. Still, given the complexity, we can only go so far.</p>
<p>One way around this high complexity is to analyze complex systems <em>compositionally</em>, which is akin
to type-checking. When proving function <code>f</code>, which calls <code>g</code>, we can abstract <code>g</code> away if we have
some specification for it, effectively replacing <code>g</code>'s implementation by what the specification
says it does. Then we prove <code>g</code> respects its specification, recursively.</p>
<p>This assumes we have a specification for sub-functions (<code>g</code>), and not just a single specification
at the top-most level (<code>f</code>). <em>Refining</em> a top-level specification to generate specifications for
the sub-functions is very difficult to do automatically (also <em>manually</em>).</p>
<p><br />
</p>
<p>To sum up, verification has at best a very high complexity. Still, in theory, if you had enough
time and memory you could just wait for an arbitrary long time and actually get an answer. Unless
you are in an <em>undecidable</em> logic fragment: you cannot know in advance if you will get an answer,
even if you wait for an infinite amount of time and memory.</p>
<p>That's not great either, and in fact this is (probably) what happened to us on</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len ≥ 0&quot;: len ≥ 0,
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
	// new
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>when we got</p>
<pre><code class="language-bash">&gt; mikino --z3_cmd &quot;z3 -T:5&quot; check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
|===| Error
| smt-level error:
| - smt solver reported `timeout`
| - during step check
|===|
</code></pre>
<p>We have been in an undecidable fragment all along (since we use non-linear arithmetic). But so far,
we managed to only send Z3 checks it could handle. The last candidate we added, <code>i % grouping = 0</code>,
apparently made our checks escape Z3's abilities.</p>
<p>And that's pretty much it, we will not prove <code>done ⇒ i = len</code> and probably not other interesting
properties such as <em>&quot;the upper bound of the interval <code>i..(i + grouping)</code> must be <code>≤ len</code> (interval
exclusive on the upper bound)&quot;</em> (or simply <code>i + grouping ≤ len</code>) either.</p>
<p>Or maybe what we could do is...</p>
<p><br />
</p>
<h2 id="settling-for-the-next-best-thing"><a class="header" href="#settling-for-the-next-best-thing">Settling For The Next Best Thing</a></h2>
<p>Our current system is very loose on what <code>len</code> and <code>grouping</code> could be. We cannot say much on
<code>grouping</code> as it is given to the code at runtime. It can be anything (module the constructor's
checks) and we have no control over it at compile-time (verification-time). But <code>len</code> is different.</p>
<p>It is actually not unknown at compile-time since it is a <code>const</code>, <em>i.e.</em> a value that can be
computed when compiling ---at least when compiling a binary using this code, but not necessarily
when compiling a library. See section <a href="strength/index.html#rust-system">Rust System</a> for the full Rust code of the
system. More precisely, different version of our case-study might be used: with <code>len = 3</code>, <code>len = 7</code>... But the point is that, due to how Rust works (<em>monomorphization</em> in particular), there is a
finite number of actual <code>len</code> values and we know all of them. (Again, at least when compiling a
binary.)</p>
<p><br />
</p>
<p>So, maybe, instead the loose constraint <code>len ≥ 0</code> and trying to conduct a proof for any value of
<code>len</code> (which does not work, as we have seen), we could check each possible value of <code>len</code>
separately. Notice that <code>len</code> is used in a non-linear <code>mod</code> application, <code>len % grouping</code>:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len ≥ 0&quot;: len ≥ 0,
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
	// new
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Checking for the concrete possible values of <code>len</code> instead would remove this non-linear <code>mod</code> and,
maybe, simplify our checks enough that Z3 can handle them. Let's try with <code>len = 8</code>; we could
remove the <code>len</code> state variable altogether, but we can try simply forcing it to be <code>8</code>. To do this,
first we need to change <code>init</code> slightly:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>init {
    len = 8, // new
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Nothing to do on <code>trans</code>, it does not mention <code>len</code> anyway. The candidate <code>len ≥ 0</code> changes to
become more precise though:</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len is 8&quot;: len = 8, // changed
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>While we still have the non-linear <code>len % grouping</code>, the (candidate) invariant <code>len = 8</code> might
actually be enough for Z3 to handle the checks on this system. We shall see.</p>
<p>Full code in the <a href="strength/index.html#version-6">Version 6</a> section. Crossing our fingers, we nervously run mikino:</p>
<pre><code class="language-text">&gt; mikino --z3_cmd &quot;z3 -T:5&quot; check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
success: all candidate(s) are inductive

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - all candidates are inductive (preserved by the transition relation)
|
| - system is safe, all reachable states verify the candidate(s)
|===|
</code></pre>
<p>🎊 🎉 👏 🎊</p>
<p><br />
</p>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>We proved the lower bound of the interval in <code>&amp;arr[i..(i + grouping)]</code> is legal 🎉. But that's not
enough for the program to be safe, since we have not proved that the upper bound is legal. That is,
prove that <code>i + grouping ≤ len</code> (interval <em>still exclusive</em> on the upper bound 😔).</p>
<p>By now you might be familiar enough with induction's <em>step</em> checks to be able to anticipate whether
this candidate is going to be inductive or not.</p>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;not done then i + grouping ≤ len&quot;: // new
		¬done ⇒ i + grouping ≤ len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len is 8&quot;: len = 8, // changed
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Full code in the <a href="strength/index.html#version-7">Version 7</a> section.</p>
<p>🥁🥁🥁🥁🥁🥁</p>
<pre><code class="language-text">&gt; mikino --z3_cmd &quot;z3 -T:5&quot; check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
success: all candidate(s) are inductive

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - all candidates are inductive (preserved by the transition relation)
|
| - system is safe, all reachable states verify the candidate(s)
|===|
</code></pre>
<p>🎉</p>
<p><br />
</p>
<p>It might be disappointing that we had to choose a value for the length, <em>i.e.</em> that we did not
prove that <code>fold</code>'s array accesses are legal when <code>len</code> is <code>8</code>. Unfortunately, in its current
state, Z3 cannot handle to have <code>len</code> as an unknown value because of the non-linear applications of
modulo.</p>
<p>This means that, assuming we are verifying a binary, we can conduct the same proof for all <code>len</code>
values actually used by the program. It would be much better to verify <code>fold</code> for any length, but
this illustrates the kind of trade-offs that are often necessary in a verification process due to
the very high complexity (and sometimes undecidability) of the checks intrinsic to the verification
approach.</p>
<p><br />
</p>
<h2 id="full-code-for-all-examples-4"><a class="header" href="#full-code-for-all-examples-4">Full Code for All Examples</a></h2>
<h3 id="rust-system"><a class="header" href="#rust-system">Rust System</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust">#![allow(non_upper_case_globals)]

pub struct Wrap&lt;T, const len: usize&gt; {
    arr: [T; len],
    grouping: usize,
}
impl&lt;T, const len: usize&gt; Wrap&lt;T, len&gt; {
    /// Constructor.
    pub fn new(arr: [T; len], grouping: usize) -&gt; Self {
        if len % grouping != 0 {
            panic!(
                &quot;grouping value {} is not a multiple of array length ({})&quot;,
                grouping, len,
            );
        }
        if grouping &lt; 1 {
            panic!(&quot;illegal grouping value {}, must be &gt; 0&quot;, grouping)
        }
        Self { arr, grouping }
    }
    /// Grouped fold.
    pub fn fold&lt;Acc&gt;(&amp;self, init: Acc, mut next: impl FnMut(Acc, &amp;[T]) -&gt; Acc) -&gt; Acc {
        let (arr, grouping) = (&amp;self.arr, self.grouping);
        let mut acc = init;
        let mut i = 0;
        while i &lt; len {
            let next_i = i + grouping;
            acc = next(acc, &amp;arr[i..next_i]);
            i = next_i
        }
        acc
    }
}

fn main() {
    // `len` ~~~~~~v
    let arr: [f64; 6] = [0., 1., 2., 3., 4., 5.];
    // `grouping` ~~~~~~~~~~~~v
    let wrap = Wrap::new(arr, 3);
    let value_1 = wrap.fold(0., |acc, arr| {
        println!(
            &quot;len: {} | arr[0]: {}, arr[1]: {}, arr[2]: {}&quot;,
            arr.len(),
            arr[0],
            arr[1],
            arr[2]
        );
        assert_eq!(arr.len(), 3);
        let new_acc = acc + arr[0] * arr[1] * arr[2];
        println!(&quot;acc: {}, new_acc: {}&quot;, acc, new_acc);
        new_acc
    });
    println!(&quot;fold result: {}&quot;, value_1);

    println!(&quot;\n---------------------\n&quot;);

    // `len` ~~~~~~v
    let arr: [f64; 6] = [0., 1., 2., 3., 4., 5.];
    // `grouping` ~~~~~~~~~~~~v
    let wrap = Wrap::new(arr, 2);
    let value_2 = wrap.fold(0., |acc, arr| {
        println!(
            &quot;len: {} | arr[0]: {}, arr[1]: {}&quot;,
            arr.len(),
            arr[0],
            arr[1]
        );
        assert_eq!(arr.len(), 2);
        let new_acc = acc + arr[0] * arr[1];
        println!(&quot;acc: {}, new_acc: {}&quot;, acc, new_acc);
        new_acc
    });
    println!(&quot;fold result: {}&quot;, value_2);
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">len: 3 | arr[0]: 0, arr[1]: 1, arr[2]: 2
acc: 0, new_acc: 0
len: 3 | arr[0]: 3, arr[1]: 4, arr[2]: 5
acc: 0, new_acc: 60
fold result: 60

---------------------

len: 2 | arr[0]: 0, arr[1]: 1
acc: 0, new_acc: 0
len: 2 | arr[0]: 2, arr[1]: 3
acc: 0, new_acc: 6
len: 2 | arr[0]: 4, arr[1]: 5
acc: 6, new_acc: 26
fold result: 26
</code></pre>
</details>
<h3 id="version-1-3"><a class="header" href="#version-1-3">Version 1</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len ≥ 0,
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;candidate&quot;: ¬(len = 8 ⋀ grouping = 4 ⋀ i = len),
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
running BMC, looking for falsifications for 1 candidate(s)...
checking for falsifications at depth 0
checking for falsifications at depth 1
checking for falsifications at depth 2
found a falsification at depth 2:
- `candidate` = (not (and (= len 8) (= grouping 4) (= i len)))
  |=| Step 0
  |     done = false
  | grouping = 4
  |        i = 0
  |      len = 8
  |=| Step 1
  |     done = false
  | grouping = 4
  |        i = 4
  |      len = 8
  |=| Step 2
  |     done = true
  | grouping = 4
  |        i = 8
  |      len = 8
  |=| Z3 produced the following unexpected values
  | div0 ((x!0 int) (x!1 int)) int = 2
  | mod0 ((x!0 int) (x!1 int)) int = 0
  |=|

|===| Bmc result
| - found a falsification for the following candidate(s)
|   `candidate`
|
| - system is unsafe
|===|
</code></pre>
</details>
<h3 id="version-2-3"><a class="header" href="#version-2-3">Version 2</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len ≥ 0,
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `done then i = len` = (=&gt; done (= i len))
  |=| Step k
  |     done = false
  | grouping = 2
  |        i = (- 1)
  |      len = 0
  |=| Step k + 1
  |     done = true
  | grouping = 2
  |        i = 1
  |      len = 0
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `done then i = len`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `not done then i &lt; len`
|===|
</code></pre>
</details>
<h3 id="version-3-2"><a class="header" href="#version-3-2">Version 3</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len ≥ 0,
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `done then i = len` = (=&gt; done (= i len))
  |=| Step k
  |     done = false
  | grouping = 2
  |        i = 0
  |      len = 1
  |=| Step k + 1
  |     done = true
  | grouping = 2
  |        i = 2
  |      len = 1
  |=|
- `i ≥ 0` = (&gt;= i 0)
  |=| Step k
  |     done = false
  | grouping = (- 1)
  |        i = 0
  |      len = 1
  |=| Step k + 1
  |     done = false
  | grouping = (- 1)
  |        i = (- 1)
  |      len = 1
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `done then i = len`
|   `i ≥ 0`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `not done then i &lt; len`
|===|
</code></pre>
</details>
<h3 id="version-4-1"><a class="header" href="#version-4-1">Version 4</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len ≥ 0,
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	// new
	&quot;len ≥ 0&quot;: len ≥ 0,
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
failed: the following candidate(s) are not inductive:
- `done then i = len` = (=&gt; done (= i len))
  |=| Step k
  |     done = false
  | grouping = 2
  |        i = 3
  |      len = 4
  |=| Step k + 1
  |     done = true
  | grouping = 2
  |        i = 5
  |      len = 4
  |=| Z3 produced the following unexpected values
  | div0 ((x!0 int) (x!1 int)) int = 2
  | mod0 ((x!0 int) (x!1 int)) int = 0
  |=|

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - the following candidate(s) are not inductive (not preserved by the transition relation)
|   `done then i = len`
|
| - system might be unsafe, some candidate(s) are not inductive
|
| - the following candidate(s) hold in the initial state(s) and are inductive
|   and thus hold in all reachable states of the system:
|   `grouping &gt; 0`
|   `i ≥ 0`
|   `len grouping related`
|   `len ≥ 0`
|   `not done then i &lt; len`
|===|
</code></pre>
</details>
<h3 id="version-5"><a class="header" href="#version-5">Version 5</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len ≥ 0,
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len ≥ 0&quot;: len ≥ 0,
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
	// new
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino --z3_cmd &quot;z3 -T:5&quot; check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
|===| Error
| smt-level error:
| - smt solver reported `timeout`
| - during step check
|===|
</code></pre>
</details>
<h3 id="version-6"><a class="header" href="#version-6">Version 6</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len = 8, // new
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len is 8&quot;: len = 8, // changed
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
success: all candidate(s) are inductive

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - all candidates are inductive (preserved by the transition relation)
|
| - system is safe, all reachable states verify the candidate(s)
|===|
</code></pre>
</details>
<h3 id="version-7"><a class="header" href="#version-7">Version 7</a></h3>
<details>
	<summary>Expand this for the full code.</summary>
<pre><pre class="playground"><code class="language-rust  compile_fail no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svars {
	len grouping: int,
	i: int,
	done: bool,
}

init {
    len = 8, // new
	grouping ≥ 1,
	i = 0,
	done = ¬(i &lt; len),
	len % grouping = 0,
}

// Encodes iteration `(pre i)`, NOT iteration `i`. That is, `trans` encodes the
// iteration where we access `arr` with the interval `(pre i)..((pre i) + grouping)`.
trans {
	'grouping = grouping,
	'len = len,
	// NEW value of the `done` flag, if `true` there will be no further iteration.
    'done = ¬('i &lt; 'len),
	if done {
		// just maintain the value;
		'i = i
	} else {
		// otherwise, `i` is incremented by `grouping`.
		'i = i + grouping
	},
}

candidates {
	&quot;not done then i &lt; len&quot;: ¬done ⇒ i &lt; len,
	&quot;not done then i + grouping ≤ len&quot;: // new
		¬done ⇒ i + grouping ≤ len,
	&quot;done then i = len&quot;: done ⇒ i = len,

	&quot;i ≥ 0&quot;: i ≥ 0,
	&quot;len is 8&quot;: len = 8, // changed
	&quot;grouping &gt; 0&quot;: grouping &gt; 0,
	&quot;len grouping related&quot;: len % grouping = 0,
    &quot;i % grouping = 0&quot;: i % grouping = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; mikino check test.mkn
checking base case...
success: all candidate(s) hold in the base state

checking step case...
success: all candidate(s) are inductive

|===| Induction attempt result
| - all candidates hold in the initial state(s)
|
| - all candidates are inductive (preserved by the transition relation)
|
| - system is safe, all reachable states verify the candidate(s)
|===|
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>If you have understood (most of) what we have discussed, congratulations 🎉. I hope some readers
might be encouraged to develop cool verification tools, while others got enough of an understanding
on the topic of verification to have a more expert usage of verification tools, <em>if</em> (and most
likely <em>when</em>) they start using such tools as developers.</p>
<h2 id="related-things"><a class="header" href="#related-things">Related Things</a></h2>
<p>Transition systems are not the only way to encode program verification problems. <a href="https://en.wikipedia.org/wiki/Horn_clause" title="Horn Clauses on wikipedia">Constrained Horn
Clauses</a> (CHC-s) are very popular at the time of writing, and for good reasons. Basically,
CHC-s represent a program (or program-like structure) in a more fragmented way than transition
systems. Techniques based on a CHC representation tend to have a fine-grain vision of the notion of
<em>transition</em>, which allows for more precision (efficiency) in the verification approach built on
top of it.</p>
<p>Besides pure induction, there are many other techniques that are worth looking into. A pretty
important one is <strong>P</strong>roperty <strong>D</strong>irected <strong>R</strong>eachability (PDR), also known as <strong>I</strong>ncremental
<strong>C</strong>onstruction of <strong>I</strong>nductive <strong>C</strong>lauses for <strong>I</strong>ndubitable <strong>C</strong>orrectness (IC3).
Unfortunately, PDR/IC3 is mostly discussed in academic papers and I could not find a presentation
understandable without a serious background in formal logics. This is partially due to the fact
that PDR is still quite recent, but also to its complex and intricate nature. Here are a few links
though, all of them are <strong>PDF</strong>:</p>
<ul>
<li><a href="http://alcom.ee.ntu.edu.tw/system/privatezone/meetingfile/201010222258251.pdf">original paper</a></li>
<li><a href="https://www.cs.utexas.edu/%7Eragerdl/fmcad11/papers/7.pdf">efficient PDR</a></li>
<li><a href="https://www.cs.utexas.edu/users/hunt/FMCAD/FMCAD17/preprints/s6p3.pdf">IC3 + k-induction</a></li>
</ul>
<p>It should be noted that PDR is particularly interesting in the purely propositional case. That is,
for systems that can be expressed using nothing but booleans. Systems using arithmetic, arrays,
strings... are more difficult to handle because of one of the necessary PDR steps (pre-image
computation), as well as certain crucial optimization that only apply on purely propositional
formulas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-mikino"><a class="header" href="#appendix-mikino">Appendix: Mikino</a></h1>
<p>Mikino is written in <a href="https://www.rust-lang.org">Rust</a> and is available as a Rust library</p>
<ul>
<li>https://crates.io/crates/mikino_api</li>
<li>https://docs.rs/mikino_api/0.9.1/mikino_api</li>
</ul>
<p>and a Rust birany</p>
<ul>
<li>https://crates.io/crates/mikino</li>
</ul>
<p>So, if you already have Rust installed on your system (or don't mind <a href="https://www.rust-lang.org/tools/install">installing it</a>)
just make sure it is up-to-date and ask <code>cargo</code> to install mikino for you.</p>
<pre><code class="language-bash"># update rust
&gt; rustup self update
&gt; rustup update

# install mikino, `-f` allows overwriting (updating)
# the previous mikino install if any
&gt; cargo install -f mikino
</code></pre>
<p><br />
</p>
<p>Otherwise, head to <a href="https://github.com/OCamlPro/mikino_bin/releases">mikino's release page</a> and download the latest release for your
operating system. The only other alternative is to <a href="mikino_install/index.html#build">build mikino from scratch</a>.</p>
<p></p>
<h2 id="z3-1"><a class="header" href="#z3-1">Z3</a></h2>
<p>Mikino requires <a href="https://github.com/Z3Prover/z3">the Z3 SMT solver</a>. You can build it from source or recover a binary from the
<a href="https://github.com/Z3Prover/z3/releases">release page</a>.</p>
<p>From this point forward I assume readers have a Z3 binary called <code>z3</code> in their path. That is,
running the command <code>z3 -version</code> should not fail and produce an output similar to</p>
<pre><code class="language-text">Z3 version 4.8.13 - 64 bit
</code></pre>
<p>Mikino, by default, assumes a Z3 binary is in your <code>PATH</code> with name <code>z3</code>. You can override this
with the <code>--z3_cmd</code> command-line argument: <code>mikino --z3_cmd &quot;my_z3&quot; ...</code>, or <code>mikino --z3_cmd &quot;path/to/my_z3&quot; ...</code> if Z3 is not in your <code>PATH</code>.</p>
<p></p>
<p>Note that other efficient solvers exist such as <a href="https://alt-ergo.ocamlpro.com" title="Alt-Ergo homepage">Alt-Ergo</a>, <a href="https://cvc4.github.io/" title="CVC4 homepage">CVC4</a> and <a href="https://yices.csl.sri.com" title="Yices 2 homepage">Yices 2</a>.
Solvers tend to be perform well on different kinds of problem, and verification frameworks
routinely run several of them in parallel, wait for the quickest answer, and discard solver
instances that are still running.</p>
<p></p>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<p>You can also build mikino, it's actually quite easy. <a href="https://www.rust-lang.org/tools/install">Install Rust</a> or make sure it
is up-to-date if it is installed already.</p>
<pre><code class="language-bash"># update rust
&gt; rustup self update
&gt; rustup update
</code></pre>
<p>Clone <a href="https://github.com/OCamlPro/mikino_bin">mikino's (binary) repo</a>, and <code>cargo build</code> it:</p>
<pre><code class="language-bash">&gt; clone https://github.com/OCamlPro/mikino_bin
&gt; cd mikino_bin

# debug, unoptimized build
&gt; cargo build
&gt; ./target/debug/mikino -V
mikino 0.9.1

# release, optimized build
&gt; cargo build --release
&gt; ./target/release/mikino -V
mikino 0.9.1
</code></pre>
<p>Alternatively, you can ask <code>cargo</code> to install your local clone of the repo:</p>
<pre><code class="language-bash">&gt; clone https://github.com/OCamlPro/mikino_bin
&gt; cargo install --path mikino_bin
&gt; mikino -V
mikino 0.9.1
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
