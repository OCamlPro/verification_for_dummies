<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SMT and Transition Systems - Verification For Dummies: SMT and Induction by OCamlPro</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="../preface/index.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item "><a href="../smt/index.html"><strong aria-hidden="true">3.</strong> SMT Solvers</a></li><li class="chapter-item "><a href="../trans/index.html"><strong aria-hidden="true">4.</strong> Transition Systems</a></li><li class="chapter-item expanded "><a href="../trans_smt/index.html" class="active"><strong aria-hidden="true">5.</strong> SMT and Transition Systems</a></li><li class="chapter-item "><a href="../bmc/index.html"><strong aria-hidden="true">6.</strong> Unrolling and BMC</a></li><li class="chapter-item "><a href="../mikino_bmc/index.html"><strong aria-hidden="true">7.</strong> BMC: Mikino</a></li><li class="chapter-item "><a href="../induction/index.html"><strong aria-hidden="true">8.</strong> Induction</a></li><li class="chapter-item "><a href="../mikino_induction/index.html"><strong aria-hidden="true">9.</strong> Induction: Mikino and Step Cex-s</a></li><li class="chapter-item "><a href="../strength/index.html"><strong aria-hidden="true">10.</strong> Candidate Strengthening</a></li><li class="chapter-item "><a href="../conclusion/index.html"><strong aria-hidden="true">11.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Verification For Dummies: SMT and Induction by OCamlPro</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="smt-and-transition-systems"><a class="header" href="#smt-and-transition-systems">SMT and Transition Systems</a></h1>
<p>Time to use Z3 again: let's try to <code>assert</code> our transition relation so that we can use Z3 to answer
questions about the system. To do this, we need to write our transition relation in <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a>.</p>
<p><br />
</p>
<p>There's two new aspects of <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> that will make things easier for us. First, SMT-LIB
identifiers can be <em>quoted</em> which means they can have form <code>|...|</code> where <code>...</code> is a sequence of
pretty much any character but <code>|</code>. This is convenient as it allows us to write, for example,
identifiers such as <code>|s'.is_counting|</code>. This will make things more readable, hopefully.</p>
<p>Second, <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> allows us to <em>define functions</em> using the <code>define-fun</code> command. Its
shape is</p>
<pre><code class="language-text">(define-fun &lt;ident&gt; ( &lt;args&gt; ) &lt;type&gt;
	&lt;expression&gt;
)
</code></pre>
<p>where <code>&lt;args&gt;</code> is zero or more whitespace-separated arguments <code>(&lt;ident&gt; &lt;type&gt;)</code>. For example:</p>
<pre><code class="language-text">(define-fun add_1 ( (n Int) ) Int
	(+ n 1)
)
(define-fun is_even ( (n Int) ) Bool
	(= (mod n 2) 0)
)

(declare-const n Int)
(assert
	(is_even (add_1 n))
)

; Is there an `n` such that `n + 1` is even? (yes)
(check-sat)
(get-model)
</code></pre>
<p>Running Z3, we obtain</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun n () Int
    (- 1))
)
</code></pre>
<p><br />
</p>
<p>So, let's define a function for our transition relation. The definition is a bit daunting because,
again, <a href="http://smtlib.cs.uiowa.edu" title="SMT-LIB homepage">SMT-LIB 2</a> is really designed to be parsed by solvers. Human readability is not
the main concern, but relatively small examples are quite readable if indented properly.</p>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)
</code></pre>
<blockquote>
<p>Full code in the <a href="#version-1">Version 1</a> section below.</p>
</blockquote>
<p><br />
</p>
<p>Now, if we want to use this transition relation function, we need to give ourselves actual state
variables to apply it to. Let's switch notation to prepare for the more complex manipulations we
will soon investigate. Let's distinguish state variables using indices: instead of referring to <code>s</code>
and <code>s'</code> to distinguish between <em>previous</em> and <em>next</em> state, let's just say we have a state of
index <code>0</code> and another one of index <code>1</code>. So, instead of writing <code>s.cnt</code> and <code>s'.cnt</code> we can just
write <code>cnt_0</code> and <code>cnt_1</code> respectively.</p>
<pre><code class="language-text">; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)
</code></pre>
<p>We can now <code>assert</code> our <code>trans</code>ition relation over these two states, <em>i.e.</em> force state <code>1</code> to be a
successor of state <code>0</code>.</p>
<pre><code class="language-text">(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))
</code></pre>
<p>Nice ðŸ˜¸. Let's see if we can force state <code>0</code> and the inputs of state <code>1</code> to have Z3 produce a new
state that's a successor of state <code>0</code>. For instance,</p>
<ul>
<li>state <code>0</code>: <code>cnt</code> is strictly greater than <code>7</code> and <code>is_counting</code> is <code>false</code>;</li>
<li>state <code>1</code>: <code>start_stop</code> is pressed and <code>reset</code> is not.</li>
</ul>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    start_stop_1
    (not reset_1)
))

(check-sat)
(get-model)
</code></pre>
<p><br />
</p>
<p>The <code>check-sat</code> command asks Z3 whether there exists a valuation of all state variables verifying
all our constraints. Said constraints include that state <code>1</code> must be a legal successor of state <code>0</code>.</p>
<blockquote>
<p>Full code in the <a href="#version-1">Version 1</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun cnt_0 () Int
    8)
  (define-fun reset_1 () Bool
    false)
  (define-fun start_stop_1 () Bool
    true)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun cnt_1 () Int
    9)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
<p>It works. In this <em>model</em> (yours might differ), Z3 decided to have <code>cnt_0</code> be <code>8</code> which, given all
the constraints, means that <code>cnt_1</code> is <code>9</code>. This is because <code>is_counting_1</code> is <code>true</code>, which is a
consequence of the last assertion we wrote (<code>is_counting_0</code> is <code>false</code> and <code>start_stop_1</code> is
<code>true</code>).</p>
<p><br />
</p>
<p>Maybe we can ask for something more interesting, <em>i.e.</em> maybe we can actually <strong>prove</strong> something.
Let's modify our last assertion: we keep the constraints over state <code>0</code> and replace state <code>1</code>'s by
<code>cnt_1</code> must be <code>0</code>.</p>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
))

(check-sat)
(get-model)
</code></pre>
<blockquote>
<p>Note that this assertion <strong>replaces</strong> the one above where we constrained state <code>1</code>'s
inputs.</p>
</blockquote>
<p>The question we are asking Z3 is now <em>&quot;say <code>cnt &gt; 7</code> and we're not counting; is it possible then to
have <code>cnt = 0</code> in one transition?&quot;</em>.</p>
<blockquote>
<p>Full code in the <a href="#version-2">Version 2</a> section below.</p>
</blockquote>
<pre><code class="language-text">sat
(
  (define-fun start_stop_1 () Bool
    true)
  (define-fun reset_1 () Bool
    true)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun cnt_0 () Int
    8)
  (define-fun cnt_1 () Int
    0)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
<p>Z3 answers <em>&quot;yes&quot;</em> (<code>sat</code>), and shows us that by pressing <code>reset</code> in state <code>1</code>, then we have <code>cnt = 0</code>. That's fair, but what if we don't allow <code>reset</code> to be pressed in state <code>1</code>?</p>
<pre><code class="language-text">(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
    (not reset_1)
))

(check-sat)
</code></pre>
<p>Readers comfortable with our toy stopwatch system know this should not be possible. If <code>reset</code> is
not pressed, <code>cnt</code> can only increase or stay the same depending on whether the system is counting.</p>
<p>Humans (us) <em>&quot;knowing&quot;</em> this is not possible is not very valuable, as humans are notoriously great
at being wrong. Let's just ask Z3 to prove (or disprove) what we <em>know</em>.</p>
<blockquote>
<p>Full code in the <a href="#version-1">Version 1</a> section below.</p>
</blockquote>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
<p>So, Z3's answer is that <em>&quot;there exists no valuation of the state variables verifying these
constraints&quot;</em>. That is, given the constraints on state <code>0</code>, it is not possible to reach a state
where <code>cnt = 0</code> and <code>reset</code> is not pressed in one transition.</p>
<p><br />
</p>
<p>We can see this result as a consequence of a more abstract <em>property</em> of the system. That is, there
are only three possible <code>cnt</code> values in the successor of any given state. Given <code>cnt_0</code>, <code>cnt_1</code>
can only be <code>0</code>, <code>cnt_0</code>, or <code>cnt_0 + 1</code>.</p>
<p><strong>Exercise</strong>: have Z3 prove this property by rewriting the last assertion of <a href="#version-3">Version
3</a>. Check out <a href="#version-4">Version 4</a> for the solution. <strong>Hint below.</strong></p>
<details>
	<summary>Hint.</summary>
<p>Another way to look at what we want to prove is to say <em>&quot;it is not possible for <code>cnt_1</code> to be
anything else than <code>0</code>, <code>cnt_0</code>, or <code>cnt_0 + 1</code>&quot;</em>.</p>
<p>So, if we ask Z3 for a model where <code>cnt_1</code> is none of these and the answer is <code>unsat</code>, then we
would prove that <code>cnt_1</code> cannot be anything but one of these three (not necessarily distinct)
values.</p>
</details>
<p><br />
</p>
<h3 id="full-code-for-all-examples"><a class="header" href="#full-code-for-all-examples">Full Code For All Examples</a></h3>
<h4 id="version-1"><a class="header" href="#version-1">Version 1</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    start_stop_1
    (not reset_1)
))

(check-sat)
(get-model)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun cnt_0 () Int
    8)
  (define-fun reset_1 () Bool
    false)
  (define-fun start_stop_1 () Bool
    true)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun cnt_1 () Int
    9)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
</details>
<h4 id="version-2"><a class="header" href="#version-2">Version 2</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
))

(check-sat)
(get-model)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
sat
(
  (define-fun start_stop_1 () Bool
    true)
  (define-fun reset_1 () Bool
    true)
  (define-fun is_counting_1 () Bool
    true)
  (define-fun cnt_0 () Int
    8)
  (define-fun cnt_1 () Int
    0)
  (define-fun is_counting_0 () Bool
    false)
  (define-fun reset_0 () Bool
    false)
  (define-fun start_stop_0 () Bool
    false)
)
</code></pre>
</details>
<h4 id="version-3"><a class="header" href="#version-3">Version 3</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert (and
    ; constraints over state 0
    (&gt; cnt_0 7)
    (not is_counting_0)
    ; constraints over state 1's inputs
    (= cnt_1 0)
    (not reset_1)
))

(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>
<h4 id="version-4"><a class="header" href="#version-4">Version 4</a></h4>
<details>
	<summary>Expand this for the full code.</summary>
<pre><code class="language-text">(define-fun trans
    (
        ; &quot;Previous&quot; state.
        (|s.start_stop| Bool)
        (|s.reset| Bool)
        (|s.is_counting| Bool)
        (|s.cnt| Int)
        ; &quot;Next&quot; state.
        (|s'.start_stop| Bool)
        (|s'.reset| Bool)
        (|s'.is_counting| Bool)
        (|s'.cnt| Int)
    )
    Bool

    (and
        (=&gt; |s'.start_stop|
            (= |s'.is_counting| (not |s.is_counting|))
        )
        (=&gt; (not |s'.start_stop|)
            (= |s'.is_counting| |s.is_counting|)
        )
        (= |s'.cnt|
            (ite |s'.reset|
                0
                (ite |s'.is_counting|
                    (+ |s.cnt| 1)
                    |s.cnt|
                )
            )
        )
    )
)

; &quot;Previous&quot; state.
(declare-const start_stop_0 Bool)
(declare-const reset_0 Bool)
(declare-const is_counting_0 Bool)
(declare-const cnt_0 Int)
; &quot;Next&quot; state.
(declare-const start_stop_1 Bool)
(declare-const reset_1 Bool)
(declare-const is_counting_1 Bool)
(declare-const cnt_1 Int)

(assert (trans
    start_stop_0 reset_0 is_counting_0 cnt_0
    start_stop_1 reset_1 is_counting_1 cnt_1
))

(assert
    ; negate what we want to prove
    (not
        ; three possible values for `cnt_1` (not necessarily different)
        (or
            (= cnt_1 0)
            (= cnt_1 cnt_0)
            (= cnt_1 (+ cnt_0 1))
        )
    )
)

(check-sat)
</code></pre>
<p>Output:</p>
<pre><code class="language-text">&gt; z3 test.smt2
unsat
</code></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../trans/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../bmc/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../trans/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../bmc/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
